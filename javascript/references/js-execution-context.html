<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JS Execution Context & Stack</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --surface2: #1a1a28;
    --border: #2a2a40;
    --accent: #7c3aed;
    --accent2: #06b6d4;
    --accent3: #f59e0b;
    --green: #10b981;
    --red: #ef4444;
    --text: #e2e8f0;
    --muted: #64748b;
    --gec: #7c3aed;
    --fec: #06b6d4;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Syne', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(124,58,237,0.05) 1px, transparent 1px),
      linear-gradient(90deg, rgba(124,58,237,0.05) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container { max-width: 1100px; margin: 0 auto; padding: 40px 24px; position: relative; z-index: 1; }

  /* Hero */
  .hero { text-align: center; margin-bottom: 64px; }
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    line-height: 1.1;
    background: linear-gradient(135deg, #fff 30%, #7c3aed);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 12px;
  }
  .hero p { color: var(--muted); font-size: 1.1rem; }

  /* Section titles */
  .section-title {
    font-size: 1.4rem;
    font-weight: 700;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .section-title span {
    background: var(--accent);
    color: white;
    width: 28px; height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    font-family: 'JetBrains Mono', monospace;
  }

  /* Cards */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 28px;
    margin-bottom: 32px;
    position: relative;
    overflow: hidden;
  }
  .card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
  }

  /* Phase boxes */
  .phases { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
  .phase {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
  }
  .phase-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 12px;
    color: var(--accent3);
  }
  .phase-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    margin-bottom: 8px;
    font-size: 0.9rem;
    color: var(--muted);
  }
  .phase-item .dot {
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--accent3);
    flex-shrink: 0;
    margin-top: 6px;
  }

  /* EC Component diagram */
  .ec-diagram {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 16px;
  }
  .ec-box {
    border-radius: 12px;
    padding: 20px;
    border: 2px solid;
  }
  .ec-box.global { border-color: var(--gec); background: rgba(124,58,237,0.08); }
  .ec-box.func { border-color: var(--fec); background: rgba(6,182,212,0.08); }
  .ec-box-title {
    font-size: 0.75rem;
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 14px;
  }
  .ec-box.global .ec-box-title { color: var(--gec); }
  .ec-box.func .ec-box-title { color: var(--fec); }
  .ec-row {
    display: flex;
    justify-content: space-between;
    font-size: 0.85rem;
    margin-bottom: 8px;
    padding: 6px 10px;
    background: rgba(255,255,255,0.04);
    border-radius: 6px;
    font-family: 'JetBrains Mono', monospace;
  }
  .ec-key { color: var(--muted); }
  .ec-val { color: var(--text); }

  /* Code block */
  .code-block {
    background: #0d0d1a;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.8;
    overflow-x: auto;
    margin: 12px 0;
  }
  .kw { color: #c084fc; }
  .fn { color: #60a5fa; }
  .str { color: #86efac; }
  .num { color: #fbbf24; }
  .cm { color: #475569; font-style: italic; }
  .line-num { color: #334155; margin-right: 16px; user-select: none; }

  /* Stack visualizer */
  .stack-demo {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    align-items: start;
  }
  .stack-visual {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    min-height: 300px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    gap: 8px;
    position: relative;
  }
  .stack-label {
    position: absolute;
    top: 14px; left: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    color: var(--muted);
    text-transform: uppercase;
  }
  .stack-item {
    border-radius: 8px;
    padding: 10px 14px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    animation: slideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  @keyframes slideIn {
    from { opacity: 0; transform: translateY(20px) scaleY(0.8); }
    to { opacity: 1; transform: translateY(0) scaleY(1); }
  }
  .stack-item.gec { background: rgba(124,58,237,0.2); border: 1px solid rgba(124,58,237,0.4); }
  .stack-item.fec { background: rgba(6,182,212,0.2); border: 1px solid rgba(6,182,212,0.4); }
  .stack-item.fec2 { background: rgba(245,158,11,0.2); border: 1px solid rgba(245,158,11,0.4); }
  .stack-badge {
    font-size: 0.65rem;
    padding: 2px 7px;
    border-radius: 100px;
    font-weight: 700;
  }
  .gec .stack-badge { background: var(--gec); color: white; }
  .fec .stack-badge { background: var(--fec); color: #0a0a0f; }
  .fec2 .stack-badge { background: var(--accent3); color: #0a0a0f; }

  /* Step controls */
  .steps-info { display: flex; flex-direction: column; gap: 12px; }
  .step-item {
    padding: 12px 16px;
    border-radius: 10px;
    border: 1px solid var(--border);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
    opacity: 0.5;
  }
  .step-item.active {
    opacity: 1;
    border-color: var(--accent);
    background: rgba(124,58,237,0.1);
  }
  .step-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--accent);
    font-weight: 700;
    margin-bottom: 4px;
  }
  .step-desc { color: var(--text); line-height: 1.4; }
  .step-hint { color: var(--muted); font-size: 0.75rem; margin-top: 4px; }

  /* Controls */
  .controls { display: flex; gap: 10px; margin-bottom: 20px; }
  .btn {
    padding: 10px 20px;
    border-radius: 8px;
    border: none;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.03em;
  }
  .btn-primary { background: var(--accent); color: white; }
  .btn-primary:hover { background: #6d28d9; transform: translateY(-1px); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); }

  /* Concept pills */
  .pills { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 16px; }
  .pill {
    padding: 6px 14px;
    border-radius: 100px;
    font-size: 0.8rem;
    font-weight: 700;
    font-family: 'JetBrains Mono', monospace;
  }
  .pill-purple { background: rgba(124,58,237,0.2); color: #a78bfa; border: 1px solid rgba(124,58,237,0.3); }
  .pill-cyan { background: rgba(6,182,212,0.2); color: #67e8f9; border: 1px solid rgba(6,182,212,0.3); }
  .pill-amber { background: rgba(245,158,11,0.2); color: #fde68a; border: 1px solid rgba(245,158,11,0.3); }
  .pill-green { background: rgba(16,185,129,0.2); color: #6ee7b7; border: 1px solid rgba(16,185,129,0.3); }

  /* Info boxes */
  .info-box {
    border-radius: 10px;
    padding: 14px 18px;
    margin-top: 14px;
    font-size: 0.88rem;
    line-height: 1.6;
  }
  .info-box.purple { background: rgba(124,58,237,0.1); border-left: 3px solid var(--gec); }
  .info-box.cyan { background: rgba(6,182,212,0.1); border-left: 3px solid var(--fec); }
  .info-box.amber { background: rgba(245,158,11,0.1); border-left: 3px solid var(--accent3); }
  .info-box strong { color: white; }

  /* Scope chain diagram */
  .scope-chain {
    display: flex;
    flex-direction: column;
    gap: 0;
    margin-top: 16px;
  }
  .scope-level {
    border: 1px solid;
    border-radius: 12px;
    padding: 16px 20px;
    position: relative;
    margin: 6px 0;
  }
  .scope-level.l0 { border-color: var(--gec); background: rgba(124,58,237,0.06); margin: 0 60px; }
  .scope-level.l1 { border-color: var(--fec); background: rgba(6,182,212,0.06); margin: 0 30px; }
  .scope-level.l2 { border-color: var(--accent3); background: rgba(245,158,11,0.06); margin: 0; }
  .scope-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-bottom: 8px;
  }
  .l0 .scope-tag { color: var(--gec); }
  .l1 .scope-tag { color: var(--fec); }
  .l2 .scope-tag { color: var(--accent3); }
  .scope-vars {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .scope-var {
    padding: 3px 10px;
    border-radius: 5px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
  }
  .l0 .scope-var { background: rgba(124,58,237,0.25); color: #c4b5fd; }
  .l1 .scope-var { background: rgba(6,182,212,0.25); color: #a5f3fc; }
  .l2 .scope-var { background: rgba(245,158,11,0.25); color: #fde68a; }
  .arrow-down {
    text-align: center;
    color: var(--muted);
    font-size: 1.2rem;
    line-height: 1;
    margin: 0 auto;
    font-family: 'JetBrains Mono', monospace;
  }

  /* Hoisting table */
  .table { width: 100%; border-collapse: collapse; margin-top: 16px; font-size: 0.85rem; }
  .table th, .table td {
    padding: 10px 14px;
    text-align: left;
    border: 1px solid var(--border);
  }
  .table th { background: var(--surface2); font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--muted); letter-spacing: 0.08em; }
  .table tr:hover td { background: rgba(255,255,255,0.02); }
  .yes { color: var(--green); font-weight: 700; }
  .no { color: var(--red); font-weight: 700; }
  .partial { color: var(--accent3); font-weight: 700; }

  .tag { display: inline-block; padding: 1px 7px; border-radius: 4px; font-size: 0.75rem; font-family: 'JetBrains Mono', monospace; }
  .tag-purple { background: rgba(124,58,237,0.25); color: #c4b5fd; }
  .tag-cyan { background: rgba(6,182,212,0.25); color: #a5f3fc; }
  .tag-amber { background: rgba(245,158,11,0.25); color: #fde68a; }

  @media (max-width: 640px) {
    .phases, .ec-diagram, .stack-demo { grid-template-columns: 1fr; }
  }

  .divider { height: 1px; background: var(--border); margin: 40px 0; }

  p { color: var(--muted); line-height: 1.7; margin-bottom: 12px; font-size: 0.95rem; }
</style>
</head>
<body>
<div class="container">

  <div class="hero">
    <h1>JavaScript Execution Context<br>& The Call Stack</h1>
    <p>A deep visual guide ‚Äî understand how JS actually runs your code</p>
  </div>

  <!-- SECTION 1: What is EC -->
  <div class="card">
    <div class="section-title"><span>1</span> What is an Execution Context?</div>
    <p>Every time JavaScript runs code, it needs an <strong>environment</strong>. That environment is called an <strong>Execution Context (EC)</strong>. Think of it as a "box" that wraps around code and holds everything needed to run it ‚Äî variables, functions, the value of <code style="color:#a78bfa">this</code>, and a reference to the outer scope.</p>
    <p>There are <strong>3 types</strong> of execution contexts:</p>
    <div class="pills">
      <div class="pill pill-purple">üåç Global EC</div>
      <div class="pill pill-cyan">‚öôÔ∏è Function EC</div>
      <div class="pill pill-amber">üî¨ Eval EC (rare)</div>
    </div>
    <div class="info-box purple" style="margin-top:20px;">
      <strong>Global EC</strong> is created automatically when JS starts. There's always exactly one Global EC. In browsers, the global object is <code>window</code>; in Node.js it's <code>global</code>.
    </div>
    <div class="info-box cyan">
      <strong>Function EC</strong> is created every time a function is <em>called</em> (not defined). A new one is born for each invocation ‚Äî even recursive calls.
    </div>
  </div>

  <!-- SECTION 2: Phases -->
  <div class="card">
    <div class="section-title"><span>2</span> Two Phases of Execution Context Creation</div>
    <p>Every EC goes through <strong>two phases</strong> before code runs:</p>
    <div class="phases">
      <div class="phase">
        <div class="phase-title">Phase 1 ‚Äî Creation (Memory)</div>
        <div class="phase-item"><div class="dot"></div><span>JS engine scans the code</span></div>
        <div class="phase-item"><div class="dot"></div><span><code style="color:#86efac">var</code> variables ‚Üí hoisted as <code style="color:#fbbf24">undefined</code></span></div>
        <div class="phase-item"><div class="dot"></div><span>Function declarations ‚Üí stored in memory fully</span></div>
        <div class="phase-item"><div class="dot"></div><span><code style="color:#86efac">let</code> / <code style="color:#86efac">const</code> ‚Üí hoisted but stay in Temporal Dead Zone</span></div>
        <div class="phase-item"><div class="dot"></div><span><code style="color:#86efac">this</code> binding is determined</span></div>
        <div class="phase-item"><div class="dot"></div><span>Outer scope reference is set</span></div>
      </div>
      <div class="phase">
        <div class="phase-title">Phase 2 ‚Äî Execution (Code runs)</div>
        <div class="phase-item"><div class="dot"></div><span>Code runs line by line</span></div>
        <div class="phase-item"><div class="dot"></div><span>Variables get their actual values assigned</span></div>
        <div class="phase-item"><div class="dot"></div><span>Functions are called ‚Üí new ECs are created</span></div>
        <div class="phase-item"><div class="dot"></div><span>Results are computed</span></div>
        <div class="phase-item"><div class="dot"></div><span>When done, EC is popped off the call stack</span></div>
        <div class="phase-item"><div class="dot"></div><span>Memory is freed (via garbage collection)</span></div>
      </div>
    </div>
  </div>

  <!-- SECTION 3: Anatomy of an EC -->
  <div class="card">
    <div class="section-title"><span>3</span> Anatomy of an Execution Context</div>
    <p>Each EC contains three key components:</p>
    <div class="ec-diagram">
      <div class="ec-box global">
        <div class="ec-box-title">üåç Global Execution Context</div>
        <div class="ec-row"><span class="ec-key">Variable Env</span><span class="ec-val">{ x: 10, greet: fn }</span></div>
        <div class="ec-row"><span class="ec-key">Lexical Env</span><span class="ec-val">Same as Var Env</span></div>
        <div class="ec-row"><span class="ec-key">this binding</span><span class="ec-val">window / global</span></div>
        <div class="ec-row"><span class="ec-key">Outer scope</span><span class="ec-val">null</span></div>
      </div>
      <div class="ec-box func">
        <div class="ec-box-title">‚öôÔ∏è Function Execution Context</div>
        <div class="ec-row"><span class="ec-key">Variable Env</span><span class="ec-val">{ name: "Alice", result: undefined }</span></div>
        <div class="ec-row"><span class="ec-key">Lexical Env</span><span class="ec-val">Includes outer scope</span></div>
        <div class="ec-row"><span class="ec-key">this binding</span><span class="ec-val">Depends on call site</span></div>
        <div class="ec-row"><span class="ec-key">Outer scope</span><span class="ec-val">‚Üí Global EC</span></div>
      </div>
    </div>
    <div class="info-box amber" style="margin-top: 20px;">
      <strong>Lexical Environment</strong> = Variable Environment + reference to the outer (parent) EC. This is how the <strong>scope chain</strong> is built ‚Äî JS follows outer references upward until it hits null.
    </div>
  </div>

  <!-- SECTION 4: Call Stack Interactive -->
  <div class="card">
    <div class="section-title"><span>4</span> The Call Stack ‚Äî Interactive Demo</div>
    <p>The <strong>Call Stack</strong> is a LIFO (Last In, First Out) data structure that JS uses to track which EC is currently running. Step through the example below to see it in action.</p>

    <div class="code-block">
<span class="line-num">1</span><span class="kw">function</span> <span class="fn">multiply</span>(a, b) {
<span class="line-num">2</span>  <span class="kw">return</span> a * b;
<span class="line-num">3</span>}
<span class="line-num">4</span>
<span class="line-num">5</span><span class="kw">function</span> <span class="fn">square</span>(n) {
<span class="line-num">6</span>  <span class="kw">return</span> <span class="fn">multiply</span>(n, n);  <span class="cm">// calls multiply</span>
<span class="line-num">7</span>}
<span class="line-num">8</span>
<span class="line-num">9</span><span class="kw">var</span> result = <span class="fn">square</span>(<span class="num">4</span>);   <span class="cm">// calls square</span>
<span class="line-num">10</span>console.<span class="fn">log</span>(result);        <span class="cm">// 16</span>
    </div>

    <div class="controls">
      <button class="btn btn-primary" onclick="nextStep()">‚ñ∂ Next Step</button>
      <button class="btn btn-secondary" onclick="resetDemo()">‚Ü∫ Reset</button>
    </div>

    <div class="stack-demo">
      <div class="stack-visual" id="stack">
        <div class="stack-label">CALL STACK</div>
        <div style="text-align:center; color: var(--muted); font-size:0.8rem; position:absolute; bottom: 20px; left: 0; right: 0;" id="empty-msg">Stack is empty ‚Äî press Next Step</div>
      </div>
      <div class="steps-info" id="steps-info">
        <!-- steps rendered by JS -->
      </div>
    </div>
  </div>

  <!-- SECTION 5: Scope Chain -->
  <div class="card">
    <div class="section-title"><span>5</span> Scope Chain</div>
    <p>When JS looks up a variable, it starts in the <strong>current EC</strong>. If not found, it moves to the <strong>outer EC</strong>, and continues up until it reaches the Global EC. If still not found ‚Äî <code style="color:#f87171">ReferenceError</code>.</p>

    <div class="code-block">
<span class="kw">var</span> globalVar = <span class="str">"I'm global"</span>;

<span class="kw">function</span> <span class="fn">outer</span>() {
  <span class="kw">var</span> outerVar = <span class="str">"I'm in outer"</span>;

  <span class="kw">function</span> <span class="fn">inner</span>() {
    <span class="kw">var</span> innerVar = <span class="str">"I'm in inner"</span>;
    console.<span class="fn">log</span>(globalVar);   <span class="cm">// ‚úÖ found via scope chain</span>
    console.<span class="fn">log</span>(outerVar);   <span class="cm">// ‚úÖ found in outer scope</span>
    console.<span class="fn">log</span>(innerVar);   <span class="cm">// ‚úÖ found locally</span>
  }
  <span class="fn">inner</span>();
}
<span class="fn">outer</span>();
    </div>

    <div class="scope-chain">
      <div class="scope-level l2">
        <div class="scope-tag">inner() ‚Äî Innermost Scope</div>
        <div class="scope-vars">
          <span class="scope-var">innerVar = "I'm in inner"</span>
          <span class="scope-var">this ‚Üí window</span>
        </div>
      </div>
      <div class="arrow-down">‚Üì look up outer scope</div>
      <div class="scope-level l1">
        <div class="scope-tag">outer() ‚Äî Middle Scope</div>
        <div class="scope-vars">
          <span class="scope-var">outerVar = "I'm in outer"</span>
          <span class="scope-var">inner = fn</span>
        </div>
      </div>
      <div class="arrow-down">‚Üì look up outer scope</div>
      <div class="scope-level l0">
        <div class="scope-tag">Global Scope</div>
        <div class="scope-vars">
          <span class="scope-var">globalVar = "I'm global"</span>
          <span class="scope-var">outer = fn</span>
          <span class="scope-var">this ‚Üí window</span>
        </div>
      </div>
    </div>

    <div class="info-box purple" style="margin-top: 20px;">
      <strong>Key rule:</strong> Scope chain is determined by where functions are <em>written</em> (lexical scope), NOT where they are called. This is the foundation of closures.
    </div>
  </div>

  <!-- SECTION 6: Hoisting -->
  <div class="card">
    <div class="section-title"><span>6</span> Hoisting (Creation Phase Effect)</div>
    <p>Because the Creation Phase scans all declarations before code runs, <strong>hoisting</strong> happens. This is why you can call a function before its definition in code.</p>
    <table class="table">
      <thead>
        <tr>
          <th>Declaration</th>
          <th>Hoisted?</th>
          <th>Initial Value</th>
          <th>Usable before declaration?</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><span class="tag tag-purple">var x</span></td>
          <td class="yes">‚úÖ YES</td>
          <td><code style="color:#fbbf24">undefined</code></td>
          <td class="partial">‚ö†Ô∏è Yes, but returns undefined</td>
        </tr>
        <tr>
          <td><span class="tag tag-cyan">let x</span></td>
          <td class="partial">‚ö†Ô∏è Hoisted (TDZ)</td>
          <td>Temporal Dead Zone</td>
          <td class="no">‚ùå ReferenceError</td>
        </tr>
        <tr>
          <td><span class="tag tag-cyan">const x</span></td>
          <td class="partial">‚ö†Ô∏è Hoisted (TDZ)</td>
          <td>Temporal Dead Zone</td>
          <td class="no">‚ùå ReferenceError</td>
        </tr>
        <tr>
          <td><span class="tag tag-amber">function foo(){}</span></td>
          <td class="yes">‚úÖ YES</td>
          <td>Full function definition</td>
          <td class="yes">‚úÖ Yes, fully callable</td>
        </tr>
        <tr>
          <td><span class="tag tag-amber">const foo = () => {}</span></td>
          <td class="no">‚ùå Only var part</td>
          <td><code style="color:#fbbf24">undefined</code></td>
          <td class="no">‚ùå Not as a function</td>
        </tr>
      </tbody>
    </table>

    <div class="code-block" style="margin-top:16px;">
<span class="cm">// Hoisting in action</span>
console.<span class="fn">log</span>(foo());   <span class="cm">// ‚úÖ "hello" ‚Äî function hoisted fully</span>
console.<span class="fn">log</span>(x);      <span class="cm">// ‚úÖ undefined ‚Äî var hoisted but value not yet assigned</span>
<span class="cm">// console.log(y);   // ‚ùå ReferenceError ‚Äî let in TDZ</span>

<span class="kw">function</span> <span class="fn">foo</span>() { <span class="kw">return</span> <span class="str">"hello"</span>; }
<span class="kw">var</span> x = <span class="num">42</span>;
<span class="kw">let</span> y = <span class="num">99</span>;
    </div>
  </div>

  <!-- SECTION 7: Stack Overflow -->
  <div class="card">
    <div class="section-title"><span>7</span> Stack Overflow</div>
    <p>The call stack has a <strong>maximum size</strong>. If you create infinite recursion (a function calling itself with no exit), the stack fills up and JavaScript throws a <code style="color:#f87171">Maximum call stack size exceeded</code> error.</p>
    <div class="code-block">
<span class="kw">function</span> <span class="fn">recurse</span>() {
  <span class="kw">return</span> <span class="fn">recurse</span>();  <span class="cm">// no base case!</span>
}
<span class="fn">recurse</span>();  <span class="cm">// ‚ùå Stack Overflow!</span>

<span class="cm">// Stack fills like this:</span>
<span class="cm">// [recurse, recurse, recurse, recurse... 10,000+ times] ‚Üí BOOM</span>
    </div>
    <div class="info-box amber">
      <strong>Fix:</strong> Always have a base case in recursive functions that stops the recursion. Or use iteration (loops) for deep recursion.
    </div>
  </div>

  <!-- SECTION 8: The Event Loop -->
  <div class="card">
    <div class="section-title"><span>8</span> The Event Loop ‚Äî How Async Works</div>
    <p>JavaScript is <strong>single-threaded</strong> ‚Äî it can only do one thing at a time on the call stack. But we can write async code (fetch, setTimeout, etc.) without blocking. How? The <strong>Event Loop</strong> coordinates three things:</p>

    <div style="margin-top: 20px;">
      <!-- Big architecture diagram -->
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; margin-bottom: 16px;">
        <div style="background: var(--surface2); border: 2px solid var(--gec); border-radius: 12px; padding: 18px; text-align:center;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--gec); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:10px;">üì¶ Call Stack</div>
          <div style="font-size:0.82rem; color:var(--muted); line-height:1.6;">Where synchronous code runs. Only one frame at a time. JS engine lives here.</div>
        </div>
        <div style="background: var(--surface2); border: 2px solid var(--fec); border-radius: 12px; padding: 18px; text-align:center;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--fec); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:10px;">üåê Web APIs / Node APIs</div>
          <div style="font-size:0.82rem; color:var(--muted); line-height:1.6;">Browser/Node handles async work here (timers, fetch, DOM events). Runs outside JS engine.</div>
        </div>
        <div style="background: var(--surface2); border: 2px solid var(--accent3); border-radius: 12px; padding: 18px; text-align:center;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--accent3); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:10px;">üì¨ Task Queues</div>
          <div style="font-size:0.82rem; color:var(--muted); line-height:1.6;">Completed async callbacks wait here. Microtask Queue has priority over Macrotask Queue.</div>
        </div>
      </div>

      <!-- Event loop flow arrows -->
      <div style="background: var(--surface2); border: 1px solid var(--border); border-radius: 12px; padding: 20px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">Event Loop Cycle</div>
        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
          <div style="padding:8px 14px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:8px; font-size:0.82rem; font-family:'JetBrains Mono',monospace;">‚ë† Run call stack</div>
          <div style="color:var(--muted); font-size:1.2rem;">‚Üí</div>
          <div style="padding:8px 14px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:8px; font-size:0.82rem; font-family:'JetBrains Mono',monospace;">‚ë° Stack empty?</div>
          <div style="color:var(--muted); font-size:1.2rem;">‚Üí</div>
          <div style="padding:8px 14px; background:rgba(16,185,129,0.15); border:1px solid var(--green); border-radius:8px; font-size:0.82rem; font-family:'JetBrains Mono',monospace;">‚ë¢ Drain microtask queue</div>
          <div style="color:var(--muted); font-size:1.2rem;">‚Üí</div>
          <div style="padding:8px 14px; background:rgba(245,158,11,0.15); border:1px solid var(--accent3); border-radius:8px; font-size:0.82rem; font-family:'JetBrains Mono',monospace;">‚ë£ Pick 1 macrotask</div>
          <div style="color:var(--muted); font-size:1.2rem;">‚Üí</div>
          <div style="padding:8px 14px; background:rgba(124,58,237,0.15); border:1px solid rgba(124,58,237,0.4); border-radius:8px; font-size:0.82rem; font-family:'JetBrains Mono',monospace;">‚Ü© back to ‚ë†</div>
        </div>
      </div>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-top:16px;">
      <div class="info-box" style="background:rgba(16,185,129,0.1); border-left:3px solid var(--green);">
        <strong style="color:var(--green);">Microtask Queue</strong> (HIGH priority)<br>
        <span style="color:var(--muted); font-size:0.85rem;">Promise callbacks (<code>.then</code>, <code>.catch</code>), <code>await</code> continuations, <code>queueMicrotask()</code>. <strong>Entire queue is drained</strong> before the next macrotask runs.</span>
      </div>
      <div class="info-box amber">
        <strong>Macrotask Queue</strong> (NORMAL priority)<br>
        <span style="color:var(--muted); font-size:0.85rem;"><code>setTimeout</code>, <code>setInterval</code>, DOM events, <code>fetch</code> callbacks. Only <strong>one task per loop tick</strong> is pulled from here.</span>
      </div>
    </div>
  </div>

  <!-- SECTION 9: async/await -->
  <div class="card">
    <div class="section-title"><span>9</span> async / await & Execution Context</div>
    <p>An <code style="color:#a78bfa">async</code> function always returns a Promise. When it hits an <code style="color:#a78bfa">await</code>, something remarkable happens to the call stack ‚Äî its EC is <strong>suspended and removed</strong> from the stack while waiting, then <strong>resumed</strong> later.</p>

    <div class="code-block">
<span class="kw">async function</span> <span class="fn">fetchData</span>() {
  console.<span class="fn">log</span>(<span class="str">"1 ‚Äî fetchData starts"</span>);       <span class="cm">// sync, runs immediately</span>

  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">"/api/data"</span>);   <span class="cm">// ‚è∏ EC suspends here!</span>

  console.<span class="fn">log</span>(<span class="str">"3 ‚Äî got data"</span>, data);         <span class="cm">// resumes after fetch resolves</span>
  <span class="kw">return</span> data;
}

console.<span class="fn">log</span>(<span class="str">"0 ‚Äî before call"</span>);
<span class="fn">fetchData</span>();
console.<span class="fn">log</span>(<span class="str">"2 ‚Äî after call (sync continues!)"</span>);

<span class="cm">// Output order:</span>
<span class="cm">// 0 ‚Äî before call</span>
<span class="cm">// 1 ‚Äî fetchData starts</span>
<span class="cm">// 2 ‚Äî after call (sync continues!)   ‚Üê this runs BEFORE the await resolves</span>
<span class="cm">// 3 ‚Äî got data  ‚Üê runs later via microtask queue</span>
    </div>

    <!-- Step-by-step async EC lifecycle -->
    <div style="margin-top: 20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">async function EC Lifecycle</div>
      <div style="display:flex; flex-direction:column; gap:0;">

        <div style="display:grid; grid-template-columns:auto 1fr; gap:0; align-items:stretch;">
          <!-- Timeline line -->
          <div style="display:flex; flex-direction:column; align-items:center; padding-right:16px;">
            <div style="width:12px; height:12px; border-radius:50%; background:var(--gec); flex-shrink:0;"></div>
            <div style="width:2px; flex:1; background:var(--border);"></div>
          </div>
          <div style="padding-bottom:18px;">
            <div style="font-size:0.78rem; font-family:'JetBrains Mono',monospace; color:var(--gec); font-weight:700; margin-bottom:4px;">CALL</div>
            <div style="font-size:0.88rem; color:var(--text);">fetchData() is called ‚Üí new Function EC created ‚Üí pushed onto call stack</div>
            <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
              <div style="padding:3px 10px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.75rem;">Global EC</div>
              <div style="color:var(--muted);">+</div>
              <div style="padding:3px 10px; background:rgba(6,182,212,0.2); border:1px solid var(--fec); border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.75rem;">fetchData EC</div>
            </div>
          </div>
        </div>

        <div style="display:grid; grid-template-columns:auto 1fr; gap:0; align-items:stretch;">
          <div style="display:flex; flex-direction:column; align-items:center; padding-right:16px;">
            <div style="width:12px; height:12px; border-radius:50%; background:var(--accent3); flex-shrink:0;"></div>
            <div style="width:2px; flex:1; background:var(--border);"></div>
          </div>
          <div style="padding-bottom:18px;">
            <div style="font-size:0.78rem; font-family:'JetBrains Mono',monospace; color:var(--accent3); font-weight:700; margin-bottom:4px;">HIT await</div>
            <div style="font-size:0.88rem; color:var(--text);">fetch() is handed to the Web API. The async function's EC is <strong>suspended</strong> ‚Äî its state (local vars, where it paused) is saved, and it's <strong>popped off the stack</strong>.</div>
            <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
              <div style="padding:3px 10px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.75rem;">Global EC</div>
              <div style="color:var(--muted);">‚Üê only this remains!</div>
            </div>
          </div>
        </div>

        <div style="display:grid; grid-template-columns:auto 1fr; gap:0; align-items:stretch;">
          <div style="display:flex; flex-direction:column; align-items:center; padding-right:16px;">
            <div style="width:12px; height:12px; border-radius:50%; background:var(--fec); flex-shrink:0;"></div>
            <div style="width:2px; flex:1; background:var(--border);"></div>
          </div>
          <div style="padding-bottom:18px;">
            <div style="font-size:0.78rem; font-family:'JetBrains Mono',monospace; color:var(--fec); font-weight:700; margin-bottom:4px;">SYNC CODE RUNS</div>
            <div style="font-size:0.88rem; color:var(--text);">While fetch waits, the rest of the synchronous code (line after fetchData() call) runs normally on the empty stack.</div>
          </div>
        </div>

        <div style="display:grid; grid-template-columns:auto 1fr; gap:0; align-items:stretch;">
          <div style="display:flex; flex-direction:column; align-items:center; padding-right:16px;">
            <div style="width:12px; height:12px; border-radius:50%; background:var(--green); flex-shrink:0;"></div>
            <div style="width:2px; flex:1; background:var(--border);"></div>
          </div>
          <div style="padding-bottom:18px;">
            <div style="font-size:0.78rem; font-family:'JetBrains Mono',monospace; color:var(--green); font-weight:700; margin-bottom:4px;">AWAIT RESOLVES</div>
            <div style="font-size:0.88rem; color:var(--text);">fetch() completes ‚Üí a microtask is queued. Event loop sees stack is empty ‚Üí drains microtask queue ‚Üí <strong>fetchData EC is restored</strong> and pushed back onto stack with its saved state.</div>
            <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
              <div style="padding:3px 10px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.75rem;">Global EC</div>
              <div style="color:var(--muted);">+</div>
              <div style="padding:3px 10px; background:rgba(6,182,212,0.2); border:1px solid var(--fec); border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.75rem;">fetchData EC (resumed)</div>
            </div>
          </div>
        </div>

        <div style="display:grid; grid-template-columns:auto 1fr; gap:0;">
          <div style="display:flex; flex-direction:column; align-items:center; padding-right:16px;">
            <div style="width:12px; height:12px; border-radius:50%; background:var(--red); flex-shrink:0;"></div>
          </div>
          <div>
            <div style="font-size:0.78rem; font-family:'JetBrains Mono',monospace; color:var(--red); font-weight:700; margin-bottom:4px;">FINISHES</div>
            <div style="font-size:0.88rem; color:var(--text);">Code after await runs ‚Üí fetchData EC is destroyed ‚Üí popped off stack. The returned Promise resolves.</div>
          </div>
        </div>

      </div>
    </div>

    <div class="info-box purple" style="margin-top:20px;">
      <strong>Key insight:</strong> <code>await</code> doesn't block the thread. It's syntactic sugar over Promises ‚Äî it pauses <em>only that function's EC</em> and frees the call stack for other work. This is the magic that lets JS handle thousands of async operations without freezing.
    </div>
  </div>

  <!-- SECTION 10: Execution Order Quiz -->
  <div class="card">
    <div class="section-title"><span>10</span> Microtask vs Macrotask ‚Äî Execution Order</div>
    <p>This is where most developers get tripped up. The queue priority determines output order. Study this pattern carefully:</p>

    <div class="code-block">
console.<span class="fn">log</span>(<span class="str">"1 ‚Äî script start"</span>);         <span class="cm">// sync</span>

<span class="fn">setTimeout</span>(() => {
  console.<span class="fn">log</span>(<span class="str">"5 ‚Äî setTimeout"</span>);       <span class="cm">// macrotask queue</span>
}, <span class="num">0</span>);

Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => {
  console.<span class="fn">log</span>(<span class="str">"3 ‚Äî promise .then"</span>);    <span class="cm">// microtask queue</span>
});

<span class="kw">async function</span> <span class="fn">run</span>() {
  console.<span class="fn">log</span>(<span class="str">"2 ‚Äî async fn starts"</span>);  <span class="cm">// sync (before first await)</span>
  <span class="kw">await</span> Promise.<span class="fn">resolve</span>();
  console.<span class="fn">log</span>(<span class="str">"4 ‚Äî after await"</span>);      <span class="cm">// microtask queue (continuation)</span>
}

<span class="fn">run</span>();
console.<span class="fn">log</span>(<span class="str">"at end of script"</span>);       <span class="cm">// sync ‚Äî runs BEFORE promises resolve</span>

<span class="cm">// Output: 1 ‚Üí 2 ‚Üí "at end of script" ‚Üí 3 ‚Üí 4 ‚Üí 5</span>
    </div>

    <!-- Execution order visual -->
    <div style="margin-top:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Why this order?</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <div style="display:flex; gap:12px; align-items:center;">
          <div style="width:28px; height:28px; border-radius:50%; background:var(--gec); display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.85rem; flex-shrink:0;">1</div>
          <div style="font-size:0.88rem;">All <strong>synchronous code</strong> runs first ‚Äî call stack must be fully drained. <span style="color:var(--muted);">"1", "2", "at end of script"</span></div>
        </div>
        <div style="width:2px; height:14px; background:var(--border); margin-left:13px;"></div>
        <div style="display:flex; gap:12px; align-items:center;">
          <div style="width:28px; height:28px; border-radius:50%; background:var(--green); display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.85rem; flex-shrink:0; color:#0a0a0f;">2</div>
          <div style="font-size:0.88rem;"><strong>Entire microtask queue</strong> is drained next ‚Äî all Promises and await continuations. <span style="color:var(--muted);">"3", "4"</span></div>
        </div>
        <div style="width:2px; height:14px; background:var(--border); margin-left:13px;"></div>
        <div style="display:flex; gap:12px; align-items:center;">
          <div style="width:28px; height:28px; border-radius:50%; background:var(--accent3); display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.85rem; flex-shrink:0; color:#0a0a0f;">3</div>
          <div style="font-size:0.88rem;"><strong>One macrotask</strong> from the macrotask queue. setTimeout callback runs. <span style="color:var(--muted);">"5"</span></div>
        </div>
      </div>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:20px;">
      <div>
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:8px;">‚úÖ Microtasks</div>
        <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:12px; font-size:0.83rem; color:var(--muted); font-family:'JetBrains Mono',monospace; line-height:1.8;">
          Promise.then()<br>
          Promise.catch()<br>
          await (continuation)<br>
          queueMicrotask()<br>
          MutationObserver
        </div>
      </div>
      <div>
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--accent3); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:8px;">‚è± Macrotasks</div>
        <div style="background:rgba(245,158,11,0.08); border:1px solid rgba(245,158,11,0.3); border-radius:8px; padding:12px; font-size:0.83rem; color:var(--muted); font-family:'JetBrains Mono',monospace; line-height:1.8;">
          setTimeout()<br>
          setInterval()<br>
          setImmediate() [Node]<br>
          I/O callbacks<br>
          UI rendering / events
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 11: Lexical Environment Deep Dive -->
  <div class="card">
    <div class="section-title"><span>11</span> Lexical Environment ‚Äî Deep Dive</div>
    <p>The <strong>Lexical Environment</strong> is one of the most important (and most misunderstood) parts of an Execution Context. It has two components: an <strong>Environment Record</strong> (where variables live) and a <strong>reference to the outer Lexical Environment</strong> (the scope chain link).</p>

    <!-- Two components diagram -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-top:18px; margin-bottom:20px;">
      <div style="background:var(--surface2); border:2px solid var(--fec); border-radius:12px; padding:20px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--fec); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:12px;">üìã Environment Record</div>
        <p style="font-size:0.85rem; color:var(--muted); margin-bottom:10px;">Stores all the <strong>identifier bindings</strong> in the current scope ‚Äî variables, function names, parameters.</p>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.3); border-radius:6px; padding:8px 12px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">
            <span style="color:var(--muted);">Declarative Record</span> ‚Üí <span style="color:var(--fec);">let, const, var, fn params</span>
          </div>
          <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.3); border-radius:6px; padding:8px 12px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">
            <span style="color:var(--muted);">Object Record</span> ‚Üí <span style="color:var(--fec);">global vars bound to window</span>
          </div>
          <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.3); border-radius:6px; padding:8px 12px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">
            <span style="color:var(--muted);">Module Record</span> ‚Üí <span style="color:var(--fec);">ES module imports/exports</span>
          </div>
        </div>
      </div>
      <div style="background:var(--surface2); border:2px solid var(--gec); border-radius:12px; padding:20px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--gec); font-weight:700; letter-spacing:0.1em; text-transform:uppercase; margin-bottom:12px;">üîó Outer Reference</div>
        <p style="font-size:0.85rem; color:var(--muted); margin-bottom:10px;">A pointer to the <strong>parent Lexical Environment</strong>. This is what creates the scope chain. Set at function <em>definition</em> time, not call time.</p>
        <div style="background:rgba(124,58,237,0.1); border:1px solid rgba(124,58,237,0.3); border-radius:6px; padding:10px 12px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; line-height:1.8;">
          inner.[[outer]] ‚Üí outer EC<br>
          outer.[[outer]] ‚Üí global EC<br>
          global.[[outer]] ‚Üí <span style="color:var(--red);">null</span>
        </div>
      </div>
    </div>

    <!-- Variable vs Lexical env difference -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:18px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">Variable Environment vs Lexical Environment</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--accent3); font-weight:700; margin-bottom:8px; text-transform:uppercase;">Variable Environment</div>
          <div style="font-size:0.85rem; color:var(--muted); line-height:1.7;">Tracks only <strong style="color:var(--text);">var</strong> declarations and function declarations. In older spec terms, this is the "var scope". Same as Lexical Env in most cases, but <code>var</code> in a block still lives here at function level.</div>
        </div>
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--fec); font-weight:700; margin-bottom:8px; text-transform:uppercase;">Lexical Environment</div>
          <div style="font-size:0.85rem; color:var(--muted); line-height:1.7;">Tracks <strong style="color:var(--text);">all bindings</strong> including <code>let</code>, <code>const</code>, and block scopes. Each <code>{}</code> block creates its own Lexical Environment. This is why <code>let</code>/<code>const</code> are truly block-scoped.</div>
        </div>
      </div>
    </div>

    <div class="code-block">
<span class="kw">function</span> <span class="fn">outer</span>() {
  <span class="kw">var</span> x = <span class="num">1</span>;     <span class="cm">// Variable Env of outer()</span>
  <span class="kw">let</span> y = <span class="num">2</span>;     <span class="cm">// Lexical Env of outer()</span>

  <span class="kw">if</span> (<span class="kw">true</span>) {
    <span class="kw">var</span> x = <span class="num">10</span>;   <span class="cm">// SAME x ‚Äî var ignores block scope, hoisted to function</span>
    <span class="kw">let</span> y = <span class="num">20</span>;   <span class="cm">// NEW y ‚Äî let creates new Lexical Env for the block</span>
    console.<span class="fn">log</span>(y); <span class="cm">// 20 ‚Äî block's own y</span>
  }

  console.<span class="fn">log</span>(x); <span class="cm">// 10 ‚Äî var was mutated inside the block</span>
  console.<span class="fn">log</span>(y); <span class="cm">// 2  ‚Äî outer y untouched (different Lexical Env)</span>
}
    </div>

    <!-- Lexical env as nested boxes -->
    <div style="margin-top:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Lexical Environments as Nested Boxes</div>
      <!-- Global -->
      <div style="border:2px solid var(--gec); border-radius:12px; padding:16px; background:rgba(124,58,237,0.05);">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--gec); font-weight:700; margin-bottom:10px;">üåç GLOBAL LEXICAL ENV  ¬∑  outer = null</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:14px;">
          <span style="background:rgba(124,58,237,0.25); color:#c4b5fd; padding:3px 10px; border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">outer = fn</span>
        </div>
        <!-- outer() env -->
        <div style="border:2px solid var(--fec); border-radius:10px; padding:14px; background:rgba(6,182,212,0.05);">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--fec); font-weight:700; margin-bottom:10px;">‚öôÔ∏è outer() LEXICAL ENV  ¬∑  outer ‚Üí Global</div>
          <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:14px;">
            <span style="background:rgba(6,182,212,0.25); color:#a5f3fc; padding:3px 10px; border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">x = 10 <span style="opacity:0.6">(var)</span></span>
            <span style="background:rgba(6,182,212,0.25); color:#a5f3fc; padding:3px 10px; border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">y = 2 <span style="opacity:0.6">(let)</span></span>
          </div>
          <!-- if block env -->
          <div style="border:2px solid var(--accent3); border-radius:8px; padding:12px; background:rgba(245,158,11,0.05);">
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--accent3); font-weight:700; margin-bottom:8px;">üì¶ if{} BLOCK LEXICAL ENV  ¬∑  outer ‚Üí outer()</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <span style="background:rgba(245,158,11,0.25); color:#fde68a; padding:3px 10px; border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">y = 20 <span style="opacity:0.6">(let ‚Äî new binding!)</span></span>
              <span style="background:rgba(100,116,139,0.2); color:#94a3b8; padding:3px 10px; border-radius:5px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; text-decoration:line-through;">x ‚Äî NOT here (var hoists)</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="info-box cyan" style="margin-top:18px;">
      <strong>Closures explained via Lexical Environment:</strong> When a function is created, it captures a reference to its current Lexical Environment. Even after the outer function returns, the inner function keeps that reference alive ‚Äî this is exactly what a <strong>closure</strong> is.
    </div>

    <div class="code-block" style="margin-top:14px;">
<span class="kw">function</span> <span class="fn">makeCounter</span>() {
  <span class="kw">let</span> count = <span class="num">0</span>;             <span class="cm">// lives in makeCounter's Lexical Env</span>

  <span class="kw">return function</span> <span class="fn">increment</span>() {
    count++;                   <span class="cm">// accesses makeCounter's Lexical Env via closure</span>
    <span class="kw">return</span> count;
  };
}

<span class="kw">const</span> counter = <span class="fn">makeCounter</span>();
<span class="cm">// makeCounter() has returned, but its Lexical Env is STILL ALIVE</span>
<span class="cm">// because increment() holds a reference to it</span>

console.<span class="fn">log</span>(<span class="fn">counter</span>()); <span class="cm">// 1</span>
console.<span class="fn">log</span>(<span class="fn">counter</span>()); <span class="cm">// 2</span>
console.<span class="fn">log</span>(<span class="fn">counter</span>()); <span class="cm">// 3</span>
    </div>
  </div>

  <!-- SECTION 12: Event Loop Examples -->
  <div class="card">
    <div class="section-title"><span>12</span> Event Loop ‚Äî 4 Detailed Examples</div>
    <p>These examples build from simple to advanced. Each one has a prediction challenge ‚Äî try to figure out the output before reading the answer.</p>

    <!-- Example 1 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:18px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">Example 1 ‚Äî Basic Queue Order</div>
        <div style="font-size:0.72rem; color:var(--muted); font-family:'JetBrains Mono',monospace;">beginner</div>
      </div>
      <div class="code-block" style="margin:0 0 14px;">
console.<span class="fn">log</span>(<span class="str">"A"</span>);

<span class="fn">setTimeout</span>(() => console.<span class="fn">log</span>(<span class="str">"B"</span>), <span class="num">0</span>);

Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"C"</span>));

console.<span class="fn">log</span>(<span class="str">"D"</span>);

<span class="cm">// Output: A ‚Üí D ‚Üí C ‚Üí B</span>
      </div>
      <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px;">
        <div style="background:rgba(124,58,237,0.15); border:1px solid rgba(124,58,237,0.4); border-radius:8px; padding:10px; text-align:center; font-size:0.8rem;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:1rem; font-weight:700; color:var(--gec); margin-bottom:4px;">"A"</div>
          <div style="color:var(--muted); font-size:0.72rem;">1st ‚Äî sync</div>
        </div>
        <div style="background:rgba(124,58,237,0.15); border:1px solid rgba(124,58,237,0.4); border-radius:8px; padding:10px; text-align:center; font-size:0.8rem;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:1rem; font-weight:700; color:var(--gec); margin-bottom:4px;">"D"</div>
          <div style="color:var(--muted); font-size:0.72rem;">2nd ‚Äî sync</div>
        </div>
        <div style="background:rgba(16,185,129,0.15); border:1px solid rgba(16,185,129,0.4); border-radius:8px; padding:10px; text-align:center; font-size:0.8rem;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:1rem; font-weight:700; color:var(--green); margin-bottom:4px;">"C"</div>
          <div style="color:var(--muted); font-size:0.72rem;">3rd ‚Äî microtask</div>
        </div>
        <div style="background:rgba(245,158,11,0.15); border:1px solid rgba(245,158,11,0.4); border-radius:8px; padding:10px; text-align:center; font-size:0.8rem;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:1rem; font-weight:700; color:var(--accent3); margin-bottom:4px;">"B"</div>
          <div style="color:var(--muted); font-size:0.72rem;">4th ‚Äî macrotask</div>
        </div>
      </div>
    </div>

    <!-- Example 2 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:18px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">Example 2 ‚Äî Chained Promises</div>
        <div style="font-size:0.72rem; color:var(--muted); font-family:'JetBrains Mono',monospace;">intermediate</div>
      </div>
      <div class="code-block" style="margin:0 0 14px;">
console.<span class="fn">log</span>(<span class="str">"start"</span>);

Promise.<span class="fn">resolve</span>()
  .<span class="fn">then</span>(() => {
    console.<span class="fn">log</span>(<span class="str">"microtask 1"</span>);
    <span class="kw">return</span> Promise.<span class="fn">resolve</span>();   <span class="cm">// nested promise</span>
  })
  .<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"microtask 2"</span>));

Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"microtask 3"</span>));

console.<span class="fn">log</span>(<span class="str">"end"</span>);

<span class="cm">// Output: start ‚Üí end ‚Üí microtask 1 ‚Üí microtask 3 ‚Üí microtask 2</span>
<span class="cm">// Why? "microtask 2" is queued AFTER microtask 1 resolves its nested promise</span>
      </div>
      <div class="info-box amber" style="margin:0;">
        <strong>Tricky part:</strong> Returning a <code>Promise.resolve()</code> inside a <code>.then()</code> adds an extra microtask "tick" before the next <code>.then()</code> can run. So <code>microtask 3</code> sneaks in before <code>microtask 2</code>.
      </div>
    </div>

    <!-- Example 3 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:18px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">Example 3 ‚Äî setTimeout vs Promise Race</div>
        <div style="font-size:0.72rem; color:var(--muted); font-family:'JetBrains Mono',monospace;">intermediate</div>
      </div>
      <div class="code-block" style="margin:0 0 14px;">
<span class="fn">setTimeout</span>(() => console.<span class="fn">log</span>(<span class="str">"timeout 1"</span>), <span class="num">0</span>);

Promise.<span class="fn">resolve</span>()
  .<span class="fn">then</span>(() => {
    console.<span class="fn">log</span>(<span class="str">"promise 1"</span>);
    <span class="fn">setTimeout</span>(() => console.<span class="fn">log</span>(<span class="str">"timeout 2"</span>), <span class="num">0</span>); <span class="cm">// queues a NEW macrotask</span>
  })
  .<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"promise 2"</span>));

<span class="cm">// Output: promise 1 ‚Üí promise 2 ‚Üí timeout 1 ‚Üí timeout 2</span>
<span class="cm">// "timeout 2" runs LAST ‚Äî it was added to macrotask queue</span>
<span class="cm">// AFTER "timeout 1" was already sitting there</span>
      </div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:0;">
        <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:12px; font-size:0.82rem;">
          <div style="color:var(--green); font-weight:700; font-family:'JetBrains Mono',monospace; font-size:0.7rem; margin-bottom:6px; text-transform:uppercase;">Microtask Queue (runs first)</div>
          <div style="color:var(--muted);">‚ë† promise 1 runs ‚Üí queues timeout 2 as macrotask<br>‚ë° promise 2 runs</div>
        </div>
        <div style="background:rgba(245,158,11,0.08); border:1px solid rgba(245,158,11,0.3); border-radius:8px; padding:12px; font-size:0.82rem;">
          <div style="color:var(--accent3); font-weight:700; font-family:'JetBrains Mono',monospace; font-size:0.7rem; margin-bottom:6px; text-transform:uppercase;">Macrotask Queue (runs after)</div>
          <div style="color:var(--muted);">‚ë† timeout 1 (was queued first)<br>‚ë° timeout 2 (was queued during microtask)</div>
        </div>
      </div>
    </div>

    <!-- Example 4 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">Example 4 ‚Äî Multiple awaits in sequence</div>
        <div style="font-size:0.72rem; color:var(--muted); font-family:'JetBrains Mono',monospace;">advanced</div>
      </div>
      <div class="code-block" style="margin:0 0 14px;">
<span class="kw">async function</span> <span class="fn">taskA</span>() {
  console.<span class="fn">log</span>(<span class="str">"A1"</span>);
  <span class="kw">await</span> Promise.<span class="fn">resolve</span>();    <span class="cm">// suspends, queues A continuation as microtask</span>
  console.<span class="fn">log</span>(<span class="str">"A2"</span>);
  <span class="kw">await</span> Promise.<span class="fn">resolve</span>();    <span class="cm">// suspends again</span>
  console.<span class="fn">log</span>(<span class="str">"A3"</span>);
}

<span class="kw">async function</span> <span class="fn">taskB</span>() {
  console.<span class="fn">log</span>(<span class="str">"B1"</span>);
  <span class="kw">await</span> Promise.<span class="fn">resolve</span>();
  console.<span class="fn">log</span>(<span class="str">"B2"</span>);
}

<span class="fn">taskA</span>();
<span class="fn">taskB</span>();

<span class="cm">// Output: A1 ‚Üí B1 ‚Üí A2 ‚Üí B2 ‚Üí A3</span>
<span class="cm">// Each await yields control back. Tasks interleave!</span>
      </div>
      <div class="info-box purple" style="margin:0;">
        <strong>Key insight:</strong> Each <code>await</code> is a <em>yield point</em>. After A1 hits <code>await</code>, control passes to taskB which runs until its <code>await</code>. Then microtasks resolve in order: A2 ‚Üí B2 ‚Üí A3. Functions interleave around their await points ‚Äî this is cooperative multitasking.
      </div>
    </div>
  </div>

  <!-- SECTION 13: Interactive Event Loop Simulator -->
  <div class="card">
    <div class="section-title"><span>13</span> Interactive Event Loop Simulator</div>
    <p>Watch the Call Stack, Microtask Queue, and Macrotask Queue evolve in real time as this code executes. Step through each tick of the event loop.</p>

    <div class="code-block" style="margin-bottom:20px;">
<span class="cm">// The code being simulated:</span>
console.<span class="fn">log</span>(<span class="str">"script start"</span>);           <span class="cm">// ‚Üê sync</span>
<span class="fn">setTimeout</span>(<span class="fn">cb1</span>, <span class="num">0</span>);                   <span class="cm">// ‚Üê to macrotask queue</span>
Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(<span class="fn">cb2</span>);          <span class="cm">// ‚Üê to microtask queue</span>
Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(<span class="fn">cb3</span>);          <span class="cm">// ‚Üê to microtask queue</span>
console.<span class="fn">log</span>(<span class="str">"script end"</span>);             <span class="cm">// ‚Üê sync</span>
    </div>

    <div style="display:flex; gap:10px; margin-bottom:20px;">
      <button class="btn btn-primary" onclick="elNext()">‚ñ∂ Next Tick</button>
      <button class="btn btn-secondary" onclick="elReset()">‚Ü∫ Reset</button>
      <div id="el-tick" style="padding:10px 16px; background:var(--surface2); border:1px solid var(--border); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:0.8rem; color:var(--muted); display:flex; align-items:center;">Tick: <span id="el-tick-num" style="color:var(--text); margin-left:6px;">0</span></div>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:14px; margin-bottom:14px;">
      <!-- Call Stack -->
      <div style="background:var(--surface2); border:2px solid var(--gec); border-radius:12px; padding:16px; min-height:220px; display:flex; flex-direction:column; justify-content:flex-end; gap:6px; position:relative;">
        <div style="position:absolute; top:12px; left:14px; font-family:'JetBrains Mono',monospace; font-size:0.65rem; color:var(--gec); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">üì¶ Call Stack</div>
        <div id="el-stack" style="display:flex; flex-direction:column; justify-content:flex-end; gap:6px; flex:1; padding-top:30px;">
          <div style="text-align:center; color:var(--muted); font-size:0.75rem;" id="el-stack-empty">empty</div>
        </div>
      </div>
      <!-- Microtask Queue -->
      <div style="background:var(--surface2); border:2px solid var(--green); border-radius:12px; padding:16px; min-height:220px; display:flex; flex-direction:column; gap:6px; position:relative;">
        <div style="position:absolute; top:12px; left:14px; font-family:'JetBrains Mono',monospace; font-size:0.65rem; color:var(--green); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">‚ö° Microtask Queue</div>
        <div id="el-micro" style="display:flex; flex-direction:column; gap:6px; flex:1; padding-top:30px;">
          <div style="text-align:center; color:var(--muted); font-size:0.75rem;" id="el-micro-empty">empty</div>
        </div>
      </div>
      <!-- Macrotask Queue -->
      <div style="background:var(--surface2); border:2px solid var(--accent3); border-radius:12px; padding:16px; min-height:220px; display:flex; flex-direction:column; gap:6px; position:relative;">
        <div style="position:absolute; top:12px; left:14px; font-family:'JetBrains Mono',monospace; font-size:0.65rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em;">‚è± Macrotask Queue</div>
        <div id="el-macro" style="display:flex; flex-direction:column; gap:6px; flex:1; padding-top:30px;">
          <div style="text-align:center; color:var(--muted); font-size:0.75rem;" id="el-macro-empty">empty</div>
        </div>
      </div>
    </div>

    <!-- Console output and explanation -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.65rem; color:var(--muted); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:10px;">üñ• Console Output</div>
        <div id="el-console" style="font-family:'JetBrains Mono',monospace; font-size:0.82rem; color:var(--green); min-height:80px; line-height:1.8;"></div>
      </div>
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.65rem; color:var(--muted); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:10px;">üí° What's happening</div>
        <div id="el-explain" style="font-size:0.84rem; color:var(--muted); line-height:1.6;">Press "Next Tick" to start the simulation.</div>
      </div>
    </div>
  </div>

  <!-- SECTION 14: Common Pitfalls -->
  <div class="card">
    <div class="section-title"><span>14</span> Common Pitfalls & How to Avoid Them</div>

    <!-- Pitfall 1: async in loops -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--red); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">‚ö†Ô∏è Pitfall 1: await inside forEach</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--red); margin-bottom:6px;">‚ùå Broken</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">const</span> ids = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];
ids.<span class="fn">forEach</span>(<span class="kw">async</span> (id) => {
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetchUser</span>(id);
  console.<span class="fn">log</span>(data); <span class="cm">// order not guaranteed!</span>
});
<span class="cm">// forEach doesn't await ‚Äî all 3</span>
<span class="cm">// fetches fire simultaneously</span>
          </div>
        </div>
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); margin-bottom:6px;">‚úÖ Fixed ‚Äî sequential</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">for</span> (<span class="kw">const</span> id <span class="kw">of</span> ids) {
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetchUser</span>(id);
  console.<span class="fn">log</span>(data); <span class="cm">// guaranteed order</span>
}
<span class="cm">// Or parallel ‚Äî if order doesn't matter:</span>
<span class="kw">await</span> Promise.<span class="fn">all</span>(ids.<span class="fn">map</span>(<span class="fn">fetchUser</span>));
          </div>
        </div>
      </div>
    </div>

    <!-- Pitfall 2: unhandled rejection -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--red); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">‚ö†Ô∏è Pitfall 2: Unhandled Promise Rejection</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--red); margin-bottom:6px;">‚ùå Silent failure</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">async function</span> <span class="fn">load</span>() {
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">badFetch</span>();
  <span class="cm">// if badFetch() rejects,</span>
  <span class="cm">// the error disappears!</span>
}
<span class="fn">load</span>(); <span class="cm">// no .catch(), no try/catch</span>
          </div>
        </div>
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); margin-bottom:6px;">‚úÖ Proper handling</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">async function</span> <span class="fn">load</span>() {
  <span class="kw">try</span> {
    <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">badFetch</span>();
  } <span class="kw">catch</span> (err) {
    console.<span class="fn">error</span>(<span class="str">"Failed:"</span>, err);
  }
}
<span class="fn">load</span>();
          </div>
        </div>
      </div>
    </div>

    <!-- Pitfall 3: sequential vs parallel -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--red); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">‚ö†Ô∏è Pitfall 3: Unnecessary Sequential Awaits (slow!)</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--red); margin-bottom:6px;">‚ùå Sequential ‚Äî takes 2000ms</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">const</span> a = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">"/a"</span>); <span class="cm">// 1000ms</span>
<span class="kw">const</span> b = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">"/b"</span>); <span class="cm">// 1000ms</span>
<span class="cm">// total: 2000ms ‚Äî b waits for a!</span>
          </div>
        </div>
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); margin-bottom:6px;">‚úÖ Parallel ‚Äî takes ~1000ms</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">const</span> [a, b] = <span class="kw">await</span> Promise.<span class="fn">all</span>([
  <span class="fn">fetch</span>(<span class="str">"/a"</span>),   <span class="cm">// fires immediately</span>
  <span class="fn">fetch</span>(<span class="str">"/b"</span>),   <span class="cm">// fires immediately</span>
]);
<span class="cm">// total: ~1000ms ‚Äî run in parallel!</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 15: Closures & Lexical Env in Depth -->
  <div class="card">
    <div class="section-title"><span>15</span> Closures ‚Äî Lexical Environment in Action</div>
    <p>A <strong>closure</strong> is a function that remembers the Lexical Environment where it was <em>created</em>, even after that environment is gone from the call stack. This is one of the most powerful features in JS.</p>

    <!-- Example 1: Classic closure -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--fec); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Example 1 ‚Äî The Classic: Function Factory</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">function</span> <span class="fn">makeAdder</span>(x) {
  <span class="cm">// x lives in makeAdder's Lexical Env</span>
  <span class="kw">return function</span>(y) {
    <span class="kw">return</span> x + y;  <span class="cm">// closes over x ‚Äî still accessible!</span>
  };
}

<span class="kw">const</span> add5  = <span class="fn">makeAdder</span>(<span class="num">5</span>);
<span class="kw">const</span> add10 = <span class="fn">makeAdder</span>(<span class="num">10</span>);

<span class="cm">// makeAdder(5) has returned ‚Äî its EC is gone from stack</span>
<span class="cm">// but add5 still holds a reference to that Lexical Env!</span>

console.<span class="fn">log</span>(<span class="fn">add5</span>(<span class="num">3</span>));   <span class="cm">// 8  ‚Äî x=5 is alive in memory</span>
console.<span class="fn">log</span>(<span class="fn">add10</span>(<span class="num">3</span>));  <span class="cm">// 13 ‚Äî x=10 is a different Lexical Env</span>
      </div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
        <div style="background:rgba(6,182,212,0.08); border:1px solid rgba(6,182,212,0.3); border-radius:8px; padding:12px; font-size:0.82rem;">
          <div style="color:var(--fec); font-family:'JetBrains Mono',monospace; font-size:0.7rem; font-weight:700; text-transform:uppercase; margin-bottom:6px;">add5's closure</div>
          <div style="color:var(--muted);">Points to: <code style="color:#a5f3fc;">{ x: 5 }</code><br>That env lives in heap memory as long as <code>add5</code> exists.</div>
        </div>
        <div style="background:rgba(6,182,212,0.08); border:1px solid rgba(6,182,212,0.3); border-radius:8px; padding:12px; font-size:0.82rem;">
          <div style="color:var(--fec); font-family:'JetBrains Mono',monospace; font-size:0.7rem; font-weight:700; text-transform:uppercase; margin-bottom:6px;">add10's closure</div>
          <div style="color:var(--muted);">Points to: <code style="color:#a5f3fc;">{ x: 10 }</code><br>Completely separate Lexical Env ‚Äî they don't share <code>x</code>.</div>
        </div>
      </div>
    </div>

    <!-- Example 2: Closure in loops ‚Äî famous gotcha -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Example 2 ‚Äî The Loop Closure Gotcha (Classic Interview Question)</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--red); margin-bottom:6px;">‚ùå Broken ‚Äî all print 3</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">for</span> (<span class="kw">var</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  <span class="fn">setTimeout</span>(() => {
    console.<span class="fn">log</span>(i); <span class="cm">// always 3!</span>
  }, <span class="num">1000</span>);
}
<span class="cm">// var is function-scoped</span>
<span class="cm">// ONE i shared by all closures</span>
<span class="cm">// by the time callbacks fire, i=3</span>
          </div>
        </div>
        <div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); margin-bottom:6px;">‚úÖ Fixed with let ‚Äî prints 0,1,2</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  <span class="fn">setTimeout</span>(() => {
    console.<span class="fn">log</span>(i); <span class="cm">// 0, 1, 2 ‚úÖ</span>
  }, <span class="num">1000</span>);
}
<span class="cm">// let creates a NEW Lexical Env</span>
<span class="cm">// per loop iteration!</span>
<span class="cm">// Each closure captures its own i</span>
          </div>
        </div>
      </div>
      <div class="info-box amber" style="margin-top:12px;">
        <strong>Why?</strong> <code>var</code> creates ONE binding in the function's Variable Environment ‚Äî all closures share the same <code>i</code>. <code>let</code> creates a <em>new Lexical Environment per loop iteration</em>, so each closure captures a distinct <code>i</code> value.
      </div>
    </div>

    <!-- Example 3: Module pattern -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--green); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Example 3 ‚Äî Module Pattern (Private State via Closure)</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">function</span> <span class="fn">createBankAccount</span>(initialBalance) {
  <span class="kw">let</span> balance = initialBalance;  <span class="cm">// private ‚Äî inaccessible from outside</span>

  <span class="kw">return</span> {
    <span class="fn">deposit</span>(amount)  { balance += amount; },
    <span class="fn">withdraw</span>(amount) {
      <span class="kw">if</span> (amount > balance) <span class="kw">throw</span> <span class="kw">new</span> <span class="fn">Error</span>(<span class="str">"Insufficient funds"</span>);
      balance -= amount;
    },
    <span class="fn">getBalance</span>() { <span class="kw">return</span> balance; }
  };
}

<span class="kw">const</span> acc = <span class="fn">createBankAccount</span>(<span class="num">100</span>);
acc.<span class="fn">deposit</span>(<span class="num">50</span>);
console.<span class="fn">log</span>(acc.<span class="fn">getBalance</span>());   <span class="cm">// 150</span>
console.<span class="fn">log</span>(acc.balance);          <span class="cm">// undefined ‚Äî truly private!</span>
      </div>
      <div class="info-box purple" style="margin:0;">
        <strong>Module pattern:</strong> The returned object methods all close over the same <code>balance</code> variable. External code can only interact through the public API ‚Äî the Lexical Environment gives us true privacy without classes.
      </div>
    </div>
  </div>

  <!-- SECTION 16: `this` binding & Execution Context -->
  <div class="card">
    <div class="section-title"><span>16</span> <code>this</code> Binding ‚Äî The 4 Rules</div>
    <p>The value of <code style="color:#a78bfa">this</code> is determined <em>at call time</em>, not definition time (unlike the scope chain). It depends on <strong>how</strong> the function is called, not where it's written. There are exactly 4 rules:</p>

    <div style="display:flex; flex-direction:column; gap:14px; margin-top:16px;">

      <!-- Rule 1: Default -->
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
          <div style="background:var(--gec); color:white; width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.8rem; flex-shrink:0;">1</div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--gec);">DEFAULT BINDING ‚Äî standalone function call</div>
        </div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">function</span> <span class="fn">show</span>() {
  console.<span class="fn">log</span>(<span class="kw">this</span>);           <span class="cm">// window (browser) | global (Node) | undefined (strict mode)</span>
}
<span class="fn">show</span>();  <span class="cm">// ‚Üê plain function call, no owner</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);">When no explicit context is provided, <code>this</code> defaults to the global object. In <code>'use strict'</code> mode it's <code>undefined</code>.</div>
      </div>

      <!-- Rule 2: Implicit -->
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
          <div style="background:var(--fec); color:#0a0a0f; width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.8rem; flex-shrink:0;">2</div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--fec);">IMPLICIT BINDING ‚Äî method call on an object</div>
        </div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">const</span> user = {
  name: <span class="str">"Alice"</span>,
  <span class="fn">greet</span>() {
    console.<span class="fn">log</span>(<span class="kw">this</span>.name);   <span class="cm">// "Alice" ‚Äî this = user</span>
  }
};
user.<span class="fn">greet</span>();  <span class="cm">// ‚Üê object before the dot = this</span>

<span class="cm">// ‚ö†Ô∏è GOTCHA: Losing implicit binding</span>
<span class="kw">const</span> detached = user.greet;
<span class="fn">detached</span>();   <span class="cm">// undefined ‚Äî no object before dot!</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);">The object <em>before the dot</em> at call time becomes <code>this</code>. If the method is detached and called without an object, it loses this binding.</div>
      </div>

      <!-- Rule 3: Explicit -->
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
          <div style="background:var(--accent3); color:#0a0a0f; width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.8rem; flex-shrink:0;">3</div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--accent3);">EXPLICIT BINDING ‚Äî call, apply, bind</div>
        </div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">function</span> <span class="fn">introduce</span>(city, country) {
  console.<span class="fn">log</span>(<span class="str">`I'm </span><span class="kw">${this</span>.name<span class="kw">}</span><span class="str"> from </span><span class="kw">${</span>city<span class="kw">}</span><span class="str">, </span><span class="kw">${</span>country<span class="kw">}</span><span class="str">`</span>);
}
<span class="kw">const</span> person = { name: <span class="str">"Bob"</span> };

introduce.<span class="fn">call</span>(person,  <span class="str">"NYC"</span>, <span class="str">"USA"</span>);      <span class="cm">// call: args spread</span>
introduce.<span class="fn">apply</span>(person, [<span class="str">"NYC"</span>, <span class="str">"USA"</span>]);    <span class="cm">// apply: args as array</span>

<span class="kw">const</span> boundFn = introduce.<span class="fn">bind</span>(person);      <span class="cm">// bind: returns new fn, doesn't call</span>
<span class="fn">boundFn</span>(<span class="str">"NYC"</span>, <span class="str">"USA"</span>);
        </div>
        <div style="font-size:0.83rem; color:var(--muted);"><code>call</code>/<code>apply</code> invoke immediately with a forced <code>this</code>. <code>bind</code> creates a permanently bound new function that always uses the given <code>this</code>.</div>
      </div>

      <!-- Rule 4: new + arrow -->
      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
          <div style="background:var(--green); color:#0a0a0f; width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.8rem; flex-shrink:0;">4</div>
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--green);">new BINDING + ARROW FUNCTIONS (lexical this)</div>
        </div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="cm">// new ‚Äî creates new object, this = that object</span>
<span class="kw">function</span> <span class="fn">Car</span>(make) {
  <span class="kw">this</span>.make = make;  <span class="cm">// this = the new Car instance</span>
}
<span class="kw">const</span> myCar = <span class="kw">new</span> <span class="fn">Car</span>(<span class="str">"Toyota"</span>); <span class="cm">// this = myCar</span>

<span class="cm">// Arrow functions ‚Äî NO own this, inherits from surrounding scope</span>
<span class="kw">const</span> timer = {
  count: <span class="num">0</span>,
  <span class="fn">start</span>() {
    <span class="fn">setInterval</span>(() => {         <span class="cm">// arrow fn ‚Äî no own this</span>
      <span class="kw">this</span>.count++;               <span class="cm">// this = timer (from start's scope)</span>
      console.<span class="fn">log</span>(<span class="kw">this</span>.count);
    }, <span class="num">1000</span>);
  }
};
timer.<span class="fn">start</span>(); <span class="cm">// 1, 2, 3... ‚úÖ works because arrow inherits this</span>
        </div>
        <div class="info-box amber" style="margin:0;">
          <strong>Arrow functions have NO Execution Context of their own</strong> ‚Äî they have no <code>this</code>, no <code>arguments</code> object, and can't be used as constructors. <code>this</code> inside an arrow is just a lookup in the surrounding Lexical Environment.
        </div>
      </div>
    </div>

    <!-- Priority order -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px; margin-top:14px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Priority Order (highest wins)</div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; font-size:0.85rem;">
        <div style="padding:6px 14px; background:rgba(16,185,129,0.2); border:1px solid var(--green); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">new</div>
        <div style="color:var(--muted);">&gt;</div>
        <div style="padding:6px 14px; background:rgba(245,158,11,0.2); border:1px solid var(--accent3); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">call / apply / bind</div>
        <div style="color:var(--muted);">&gt;</div>
        <div style="padding:6px 14px; background:rgba(6,182,212,0.2); border:1px solid var(--fec); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">method call (obj.fn)</div>
        <div style="color:var(--muted);">&gt;</div>
        <div style="padding:6px 14px; background:rgba(124,58,237,0.2); border:1px solid var(--gec); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:0.78rem;">default (global)</div>
      </div>
    </div>
  </div>

  <!-- SECTION 17: Promise Combinators -->
  <div class="card">
    <div class="section-title"><span>17</span> Promise Combinators ‚Äî When to Use Which</div>
    <p>Beyond <code>Promise.all</code>, there are 4 combinators with different behaviors around failures. Choosing the right one is critical for robust async code.</p>

    <div style="display:flex; flex-direction:column; gap:14px; margin-top:16px;">

      <!-- Promise.all -->
      <div style="background:var(--surface2); border:1px solid rgba(16,185,129,0.4); border-radius:12px; padding:18px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--green); margin-bottom:10px;">Promise.all(promises) ‚Äî ALL must succeed</div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">const</span> [user, posts, comments] = <span class="kw">await</span> Promise.<span class="fn">all</span>([
  <span class="fn">fetchUser</span>(<span class="num">1</span>),
  <span class="fn">fetchPosts</span>(<span class="num">1</span>),
  <span class="fn">fetchComments</span>(<span class="num">1</span>),
]);
<span class="cm">// ‚úÖ All 3 run in parallel</span>
<span class="cm">// ‚ùå If ANY rejects ‚Üí entire Promise.all rejects immediately (fail-fast)</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);"><strong style="color:var(--green);">Use when:</strong> all results are required and you want them all to succeed. Best for parallel independent requests.</div>
      </div>

      <!-- Promise.allSettled -->
      <div style="background:var(--surface2); border:1px solid rgba(6,182,212,0.4); border-radius:12px; padding:18px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--fec); margin-bottom:10px;">Promise.allSettled(promises) ‚Äî wait for ALL, don't fail-fast</div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">const</span> results = <span class="kw">await</span> Promise.<span class="fn">allSettled</span>([
  <span class="fn">fetch</span>(<span class="str">"/api/a"</span>),
  <span class="fn">fetch</span>(<span class="str">"/api/b"</span>),   <span class="cm">// this one might fail</span>
  <span class="fn">fetch</span>(<span class="str">"/api/c"</span>),
]);

results.<span class="fn">forEach</span>(result => {
  <span class="kw">if</span> (result.status === <span class="str">"fulfilled"</span>) console.<span class="fn">log</span>(result.value);
  <span class="kw">if</span> (result.status === <span class="str">"rejected"</span>)  console.<span class="fn">log</span>(result.reason);
});
<span class="cm">// NEVER rejects ‚Äî always gives array of {status, value/reason}</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);"><strong style="color:var(--fec);">Use when:</strong> you want results from ALL promises regardless of failures. Great for dashboards showing partial data.</div>
      </div>

      <!-- Promise.race -->
      <div style="background:var(--surface2); border:1px solid rgba(245,158,11,0.4); border-radius:12px; padding:18px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--accent3); margin-bottom:10px;">Promise.race(promises) ‚Äî first to settle wins</div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="cm">// Timeout pattern ‚Äî fail if API is too slow</span>
<span class="kw">function</span> <span class="fn">withTimeout</span>(promise, ms) {
  <span class="kw">const</span> timeout = <span class="kw">new</span> Promise((_, reject) =>
    <span class="fn">setTimeout</span>(() => reject(<span class="kw">new</span> <span class="fn">Error</span>(<span class="str">"Timeout!"</span>)), ms)
  );
  <span class="kw">return</span> Promise.<span class="fn">race</span>([promise, timeout]);
}

<span class="kw">await</span> <span class="fn">withTimeout</span>(<span class="fn">fetch</span>(<span class="str">"/slow-api"</span>), <span class="num">3000</span>);
<span class="cm">// Rejects with "Timeout!" if fetch takes more than 3s</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);"><strong style="color:var(--accent3);">Use when:</strong> you need the first result or want to implement timeouts. The winner ‚Äî success or failure ‚Äî settles the race.</div>
      </div>

      <!-- Promise.any -->
      <div style="background:var(--surface2); border:1px solid rgba(124,58,237,0.4); border-radius:12px; padding:18px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.78rem; font-weight:700; color:var(--gec); margin-bottom:10px;">Promise.any(promises) ‚Äî first SUCCESS wins (ignore rejections)</div>
        <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="cm">// Try multiple CDN mirrors ‚Äî use whichever responds first</span>
<span class="kw">const</span> data = <span class="kw">await</span> Promise.<span class="fn">any</span>([
  <span class="fn">fetch</span>(<span class="str">"https://cdn1.example.com/data"</span>),
  <span class="fn">fetch</span>(<span class="str">"https://cdn2.example.com/data"</span>),
  <span class="fn">fetch</span>(<span class="str">"https://cdn3.example.com/data"</span>),
]);
<span class="cm">// Returns first successful result</span>
<span class="cm">// Only rejects if ALL promises reject (AggregateError)</span>
        </div>
        <div style="font-size:0.83rem; color:var(--muted);"><strong style="color:var(--gec);">Use when:</strong> you have fallback sources and just need any one to succeed. Perfect for resilient multi-source fetching.</div>
      </div>
    </div>

    <!-- Comparison table -->
    <table class="table" style="margin-top:16px;">
      <thead>
        <tr>
          <th>Combinator</th>
          <th>Resolves when</th>
          <th>Rejects when</th>
          <th>Result type</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code style="color:var(--green);">Promise.all</code></td>
          <td>ALL fulfill</td>
          <td class="no">ANY rejects (fail-fast)</td>
          <td>Array of values</td>
        </tr>
        <tr>
          <td><code style="color:var(--fec);">Promise.allSettled</code></td>
          <td>ALL settle (any result)</td>
          <td class="yes">Never rejects</td>
          <td>Array of {status, value/reason}</td>
        </tr>
        <tr>
          <td><code style="color:var(--accent3);">Promise.race</code></td>
          <td>FIRST to fulfill</td>
          <td class="partial">FIRST to reject</td>
          <td>Single value</td>
        </tr>
        <tr>
          <td><code style="color:var(--gec);">Promise.any</code></td>
          <td>FIRST to fulfill</td>
          <td class="no">ALL reject (AggregateError)</td>
          <td>Single value</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- SECTION 18: Real-World Async Patterns -->
  <div class="card">
    <div class="section-title"><span>18</span> Real-World Async Patterns</div>
    <p>These are the patterns you'll actually use in production. Each one solves a specific async coordination problem.</p>

    <!-- Pattern 1: Retry with backoff -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--fec); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Pattern 1 ‚Äî Retry with Exponential Backoff</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">async function</span> <span class="fn">fetchWithRetry</span>(url, maxRetries = <span class="num">3</span>) {
  <span class="kw">for</span> (<span class="kw">let</span> attempt = <span class="num">0</span>; attempt &lt; maxRetries; attempt++) {
    <span class="kw">try</span> {
      <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(url);
      <span class="kw">if</span> (!res.ok) <span class="kw">throw</span> <span class="kw">new</span> <span class="fn">Error</span>(<span class="str">`HTTP </span><span class="kw">${</span>res.status<span class="kw">}</span><span class="str">`</span>);
      <span class="kw">return await</span> res.<span class="fn">json</span>();           <span class="cm">// success ‚Äî return result</span>
    } <span class="kw">catch</span> (err) {
      <span class="kw">if</span> (attempt === maxRetries - <span class="num">1</span>) <span class="kw">throw</span> err;  <span class="cm">// last attempt ‚Äî give up</span>
      <span class="kw">const</span> delay = <span class="num">2</span> ** attempt * <span class="num">1000</span>;  <span class="cm">// 1s, 2s, 4s...</span>
      console.<span class="fn">log</span>(<span class="str">`Retry </span><span class="kw">${</span>attempt+<span class="num">1</span><span class="kw">}</span><span class="str"> in </span><span class="kw">${</span>delay<span class="kw">}</span><span class="str">ms`</span>);
      <span class="kw">await new</span> Promise(r => <span class="fn">setTimeout</span>(r, delay));
    }
  }
}
      </div>
      <div style="font-size:0.84rem; color:var(--muted);">The delay doubles on each retry (1s ‚Üí 2s ‚Üí 4s). <code>await new Promise(r => setTimeout(r, delay))</code> is the idiomatic way to sleep in async JS ‚Äî it creates a Promise that resolves after the timeout fires via the macrotask queue.</div>
    </div>

    <!-- Pattern 2: Async queue / rate limiting -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--gec); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Pattern 2 ‚Äî Rate-Limited Parallel Requests</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="cm">// Don't fire 1000 requests at once ‚Äî batch into groups of N</span>
<span class="kw">async function</span> <span class="fn">batchProcess</span>(items, batchSize, asyncFn) {
  <span class="kw">const</span> results = [];
  <span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; items.length; i += batchSize) {
    <span class="kw">const</span> batch = items.<span class="fn">slice</span>(i, i + batchSize);
    <span class="kw">const</span> batchResults = <span class="kw">await</span> Promise.<span class="fn">all</span>(batch.<span class="fn">map</span>(asyncFn));
    results.<span class="fn">push</span>(...batchResults);
  }
  <span class="kw">return</span> results;
}

<span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">batchProcess</span>(userIds, <span class="num">5</span>, fetchUser);
<span class="cm">// Processes 5 users at a time ‚Äî parallel within batch, sequential between batches</span>
      </div>
      <div style="font-size:0.84rem; color:var(--muted);">Combines the best of both worlds: parallel within each batch for speed, sequential batches to avoid overwhelming the server or hitting rate limits.</div>
    </div>

    <!-- Pattern 3: Cancellation with AbortController -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Pattern 3 ‚Äî Cancellable Requests (AbortController)</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">function</span> <span class="fn">useSearch</span>(query) {
  <span class="kw">let</span> controller = <span class="kw">null</span>;

  <span class="kw">return async function</span> <span class="fn">search</span>() {
    <span class="kw">if</span> (controller) controller.<span class="fn">abort</span>();   <span class="cm">// cancel previous request</span>
    controller = <span class="kw">new</span> <span class="fn">AbortController</span>();

    <span class="kw">try</span> {
      <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">`/search?q=</span><span class="kw">${</span>query<span class="kw">}</span><span class="str">`</span>, {
        signal: controller.signal
      });
      <span class="kw">return await</span> res.<span class="fn">json</span>();
    } <span class="kw">catch</span> (err) {
      <span class="kw">if</span> (err.name === <span class="str">"AbortError"</span>) <span class="kw">return null</span>;  <span class="cm">// was cancelled</span>
      <span class="kw">throw</span> err;
    }
  };
}
<span class="cm">// Each new keystroke cancels the previous search request</span>
      </div>
      <div style="font-size:0.84rem; color:var(--muted);">The closure over <code>controller</code> (Pattern 3 = Closure + async!) lets us abort in-flight requests when the user keeps typing. <code>AbortError</code> is not a real error ‚Äî handle it silently.</div>
    </div>
  </div>

  <!-- SECTION 19: Tricky Quiz Examples -->
  <div class="card">
    <div class="section-title"><span>19</span> Tricky Quiz ‚Äî Test Your Mental Model</div>
    <p>These are the questions that trip up experienced developers. Try to predict the output before revealing the answer.</p>

    <!-- Quiz 1 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Quiz 1 ‚Äî What does this print?</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">let</span> x = <span class="num">1</span>;

<span class="kw">function</span> <span class="fn">outer</span>() {
  <span class="kw">let</span> x = <span class="num">2</span>;
  <span class="kw">function</span> <span class="fn">inner</span>() {
    <span class="kw">let</span> x = <span class="num">3</span>;
    console.<span class="fn">log</span>(x);    <span class="cm">// ?</span>
  }
  <span class="fn">inner</span>();
  console.<span class="fn">log</span>(x);      <span class="cm">// ?</span>
}

<span class="fn">outer</span>();
console.<span class="fn">log</span>(x);        <span class="cm">// ?</span>
      </div>
      <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; margin-bottom:8px; text-transform:uppercase;">‚úÖ Answer: 3 ‚Üí 2 ‚Üí 1</div>
        <div style="font-size:0.84rem; color:var(--muted);">Each <code>let x</code> creates a new binding in its own Lexical Environment. Variable lookups start at the current scope and move outward ‚Äî but once found, the search stops. The global <code>x=1</code> is never touched by <code>inner()</code> or <code>outer()</code>.</div>
      </div>
    </div>

    <!-- Quiz 2 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Quiz 2 ‚Äî Hoisting Surprise</div>
      <div class="code-block" style="margin:0 0 12px;">
console.<span class="fn">log</span>(<span class="kw">typeof</span> foo);   <span class="cm">// ?</span>
console.<span class="fn">log</span>(<span class="kw">typeof</span> bar);   <span class="cm">// ?</span>
console.<span class="fn">log</span>(<span class="kw">typeof</span> baz);   <span class="cm">// ?</span>

<span class="kw">var</span> foo = <span class="num">42</span>;
<span class="kw">function</span> <span class="fn">bar</span>() { <span class="kw">return</span> <span class="num">1</span>; }
<span class="kw">let</span> baz = <span class="str">"hello"</span>;
      </div>
      <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; margin-bottom:8px; text-transform:uppercase;">‚úÖ Answer: "undefined" ‚Üí "function" ‚Üí ReferenceError</div>
        <div style="font-size:0.84rem; color:var(--muted);"><code>foo</code>: <code>var</code> is hoisted with value <code>undefined</code> ‚Üí <code>typeof undefined = "undefined"</code>. <code>bar</code>: function declaration is fully hoisted ‚Üí <code>typeof bar = "function"</code>. <code>baz</code>: <code>let</code> is in the Temporal Dead Zone ‚Üí <code>typeof</code> on a TDZ variable throws a <code>ReferenceError</code> (unlike <code>var</code> which gives <code>"undefined"</code>).</div>
      </div>
    </div>

    <!-- Quiz 3 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Quiz 3 ‚Äî Microtask Madness</div>
      <div class="code-block" style="margin:0 0 12px;">
console.<span class="fn">log</span>(<span class="str">"1"</span>);

<span class="fn">setTimeout</span>(() => console.<span class="fn">log</span>(<span class="str">"2"</span>), <span class="num">0</span>);

Promise.<span class="fn">resolve</span>()
  .<span class="fn">then</span>(() => { console.<span class="fn">log</span>(<span class="str">"3"</span>); <span class="kw">return</span> Promise.<span class="fn">resolve</span>(); })
  .<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"4"</span>));

Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">"5"</span>));

console.<span class="fn">log</span>(<span class="str">"6"</span>);
      </div>
      <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; margin-bottom:8px; text-transform:uppercase;">‚úÖ Answer: 1 ‚Üí 6 ‚Üí 3 ‚Üí 5 ‚Üí 4 ‚Üí 2</div>
        <div style="font-size:0.84rem; color:var(--muted); line-height:1.7;">
          <strong style="color:var(--text);">1, 6</strong> ‚Äî sync runs first.<br>
          <strong style="color:var(--text);">3</strong> ‚Äî first microtask runs. It returns <code>Promise.resolve()</code> ‚Äî this adds an extra "unwrapping" microtask before <code>.then("4")</code> can be queued.<br>
          <strong style="color:var(--text);">5</strong> ‚Äî second Promise's .then runs (it was queued at the same time as "3" but "4"'s slot wasn't ready yet).<br>
          <strong style="color:var(--text);">4</strong> ‚Äî finally, after the extra unwrapping tick, "4" runs.<br>
          <strong style="color:var(--text);">2</strong> ‚Äî macrotask last.
        </div>
      </div>
    </div>

    <!-- Quiz 4 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Quiz 4 ‚Äî this Binding Trap</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">const</span> obj = {
  val: <span class="num">42</span>,
  <span class="fn">regular</span>() { <span class="kw">return</span> <span class="kw">this</span>.val; },
  <span class="fn">arrow</span>: () => <span class="kw">this</span>.val,
};

console.<span class="fn">log</span>(obj.<span class="fn">regular</span>());       <span class="cm">// ?</span>
console.<span class="fn">log</span>(obj.<span class="fn">arrow</span>());          <span class="cm">// ?</span>

<span class="kw">const</span> r = obj.regular;
console.<span class="fn">log</span>(<span class="fn">r</span>());                   <span class="cm">// ?</span>
      </div>
      <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; margin-bottom:8px; text-transform:uppercase;">‚úÖ Answer: 42 ‚Üí undefined ‚Üí undefined</div>
        <div style="font-size:0.84rem; color:var(--muted); line-height:1.7;">
          <strong style="color:var(--text);">42</strong>: <code>obj.regular()</code> ‚Äî implicit binding, <code>this = obj</code>.<br>
          <strong style="color:var(--text);">undefined</strong>: <code>obj.arrow()</code> ‚Äî arrow function has NO own <code>this</code>. It was defined in the module/script scope where <code>this = undefined</code> (strict) or <code>window</code> (browser), not <code>obj</code>. <code>window.val</code> is undefined.<br>
          <strong style="color:var(--text);">undefined</strong>: <code>r()</code> ‚Äî detached call loses implicit binding. <code>this</code> defaults to global where <code>val</code> doesn't exist.
        </div>
      </div>
    </div>

    <!-- Quiz 5 -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--accent3); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">Quiz 5 ‚Äî async/await Execution Order</div>
      <div class="code-block" style="margin:0 0 12px;">
<span class="kw">async function</span> <span class="fn">foo</span>() {
  console.<span class="fn">log</span>(<span class="str">"foo 1"</span>);
  <span class="kw">await</span> <span class="kw">null</span>;
  console.<span class="fn">log</span>(<span class="str">"foo 2"</span>);
  <span class="kw">return</span> <span class="str">"done"</span>;
}

console.<span class="fn">log</span>(<span class="str">"before"</span>);
foo().<span class="fn">then</span>(v => console.<span class="fn">log</span>(<span class="str">"then:"</span>, v));
console.<span class="fn">log</span>(<span class="str">"after"</span>);
      </div>
      <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:14px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--green); font-weight:700; margin-bottom:8px; text-transform:uppercase;">‚úÖ Answer: before ‚Üí foo 1 ‚Üí after ‚Üí foo 2 ‚Üí then: "done"</div>
        <div style="font-size:0.84rem; color:var(--muted); line-height:1.7;">
          <strong style="color:var(--text);">before</strong>: sync.<br>
          <strong style="color:var(--text);">foo 1</strong>: foo() is called, runs sync until <code>await null</code>.<br>
          <strong style="color:var(--text);">after</strong>: <code>await null</code> suspends foo's EC. Sync code continues.<br>
          <strong style="color:var(--text);">foo 2</strong>: foo resumes via microtask queue after sync is done.<br>
          <strong style="color:var(--text);">then: "done"</strong>: <code>.then()</code> callback runs as another microtask after foo returns.
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 20: Code Explained Line by Line ‚Äî makeAdder -->
  <div class="card">
    <div class="section-title"><span>20</span> Line-by-Line: makeAdder Closure Explained</div>
    <p>Let's dissect the <code>makeAdder</code> example completely ‚Äî every token, every memory allocation, every scope decision ‚Äî so there are no mysteries left.</p>

    <div class="code-block" style="margin-bottom:20px; counter-reset:ln;">
<span style="color:#475569; margin-right:14px; user-select:none;">L1 </span><span class="kw">function</span> <span class="fn">makeAdder</span>(x) {
<span style="color:#475569; margin-right:14px; user-select:none;">L2 </span>  <span class="kw">return function</span>(y) {
<span style="color:#475569; margin-right:14px; user-select:none;">L3 </span>    <span class="kw">return</span> x + y;
<span style="color:#475569; margin-right:14px; user-select:none;">L4 </span>  };
<span style="color:#475569; margin-right:14px; user-select:none;">L5 </span>}
<span style="color:#475569; margin-right:14px; user-select:none;">L6 </span>
<span style="color:#475569; margin-right:14px; user-select:none;">L7 </span><span class="kw">const</span> add5  = <span class="fn">makeAdder</span>(<span class="num">5</span>);
<span style="color:#475569; margin-right:14px; user-select:none;">L8 </span><span class="kw">const</span> add10 = <span class="fn">makeAdder</span>(<span class="num">10</span>);
<span style="color:#475569; margin-right:14px; user-select:none;">L9 </span>
<span style="color:#475569; margin-right:14px; user-select:none;">L10</span><span class="fn">add5</span>(<span class="num">3</span>);   <span class="cm">// ‚Üí 8</span>
<span style="color:#475569; margin-right:14px; user-select:none;">L11</span><span class="fn">add10</span>(<span class="num">3</span>);  <span class="cm">// ‚Üí 13</span>
    </div>

    <div style="display:flex; flex-direction:column; gap:12px;">

      <div style="background:var(--surface2); border-left:3px solid var(--gec); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--gec); font-weight:700; margin-bottom:8px;">L1 ‚Äî function makeAdder(x) {</div>
        <p style="margin:0; font-size:0.88rem;">During the <strong>Creation Phase</strong>, the JS engine sees this declaration and stores the entire <code>makeAdder</code> function object in the <strong>Global Lexical Environment</strong>. The parameter <code>x</code> doesn't exist yet ‚Äî it only appears when the function is actually called. Nothing runs, nothing is allocated. The function object itself stores a hidden <code>[[Environment]]</code> slot that captures the current Lexical Environment (Global) as its parent scope.</p>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--fec); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--fec); font-weight:700; margin-bottom:8px;">L7 ‚Äî const add5 = makeAdder(5);</div>
        <p style="margin:0 0 8px; font-size:0.88rem;"><strong>Call time:</strong> A new Function Execution Context is created for <code>makeAdder</code>. Its Lexical Environment is initialized with: <code>{ x: 5 }</code>. The parameter <code>x = 5</code> is the first thing set. This EC is pushed onto the call stack.</p>
        <p style="margin:0; font-size:0.88rem;">Then L2 is reached: a brand new <strong>inner function object</strong> is created. This inner function also gets its own <code>[[Environment]]</code> slot ‚Äî and it captures the <em>current</em> Lexical Environment of <code>makeAdder</code>, which contains <code>{ x: 5 }</code>. This is the moment the closure is born.</p>
        <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.3); border-radius:8px; padding:10px; margin-top:10px; font-family:'JetBrains Mono',monospace; font-size:0.8rem; color:#a5f3fc;">
          inner_fn.[[Environment]] ‚Üí makeAdder_LexEnv { x: 5 }
        </div>
        <p style="margin:8px 0 0; font-size:0.88rem;"><code>makeAdder</code>'s EC is <strong>popped from the stack</strong> (function returned). But its Lexical Environment <strong>stays alive in heap memory</strong> because <code>add5</code> holds a reference to it through the closure.</p>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--accent3); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--accent3); font-weight:700; margin-bottom:8px;">L8 ‚Äî const add10 = makeAdder(10);</div>
        <p style="margin:0; font-size:0.88rem;"><code>makeAdder</code> is called a second time. A <strong>completely separate</strong> Function EC and Lexical Environment is created: <code>{ x: 10 }</code>. A new inner function is created with its own <code>[[Environment]]</code> pointing to this new env. <code>add5</code> and <code>add10</code> are independent ‚Äî they each hold a reference to a different Lexical Environment in memory. They do not share <code>x</code>.</p>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--green); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:8px;">L10 ‚Äî add5(3) ‚Üí 8</div>
        <p style="margin:0 0 8px; font-size:0.88rem;">A new Function EC is created for the inner function call. Its Lexical Environment: <code>{ y: 3 }</code>. Its outer reference points to <code>makeAdder_LexEnv { x: 5 }</code>.</p>
        <p style="margin:0; font-size:0.88rem;">L3: <code>return x + y</code>. Scope lookup: Is <code>x</code> in current env? No ‚Äî only <code>y</code> is. Walk up to outer env: <code>{ x: 5 }</code>. Found! <code>x = 5</code>. <code>y = 3</code> (local). Result: <code>5 + 3 = 8</code>.</p>
      </div>

    </div>

    <!-- Memory diagram -->
    <div style="margin-top:20px; background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">Memory Layout After L8</div>
      <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; font-size:0.8rem; font-family:'JetBrains Mono',monospace;">
        <div style="background:rgba(124,58,237,0.1); border:1px solid rgba(124,58,237,0.4); border-radius:8px; padding:12px;">
          <div style="color:var(--gec); font-weight:700; margin-bottom:8px; font-size:0.7rem; text-transform:uppercase;">Global Env (stack)</div>
          <div style="color:var(--muted); line-height:2;">makeAdder: fn<br>add5: fn_ref_A<br>add10: fn_ref_B</div>
        </div>
        <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.4); border-radius:8px; padding:12px;">
          <div style="color:var(--fec); font-weight:700; margin-bottom:8px; font-size:0.7rem; text-transform:uppercase;">Heap: Env_A (kept alive by add5)</div>
          <div style="color:var(--muted); line-height:2;">x: 5<br>outer ‚Üí Global</div>
        </div>
        <div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.4); border-radius:8px; padding:12px;">
          <div style="color:var(--accent3); font-weight:700; margin-bottom:8px; font-size:0.7rem; text-transform:uppercase;">Heap: Env_B (kept alive by add10)</div>
          <div style="color:var(--muted); line-height:2;">x: 10<br>outer ‚Üí Global</div>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 21: Scope Deep Dive -->
  <div class="card">
    <div class="section-title"><span>21</span> Scope ‚Äî The Complete Guide</div>
    <p>Scope determines <strong>where in your code a variable can be accessed</strong>. JavaScript has 5 kinds of scope, each with its own rules and Lexical Environment.</p>

    <!-- 5 scope types -->
    <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:20px;">

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:grid; grid-template-columns:200px 1fr; gap:16px; align-items:start;">
          <div>
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--gec); font-weight:700; text-transform:uppercase; margin-bottom:6px;">‚ë† Global Scope</div>
            <div style="font-size:0.8rem; color:var(--muted);">Accessible everywhere. Lives on <code>window</code> / <code>global</code>.</div>
          </div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">var</span> globalVar = <span class="str">"I'm everywhere"</span>;  <span class="cm">// attached to window</span>
<span class="kw">let</span> globalLet = <span class="str">"also global"</span>;       <span class="cm">// NOT on window (script scope)</span>
console.<span class="fn">log</span>(window.globalVar);  <span class="cm">// "I'm everywhere"</span>
console.<span class="fn">log</span>(window.globalLet);  <span class="cm">// undefined</span>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:grid; grid-template-columns:200px 1fr; gap:16px; align-items:start;">
          <div>
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--fec); font-weight:700; text-transform:uppercase; margin-bottom:6px;">‚ë° Function Scope</div>
            <div style="font-size:0.8rem; color:var(--muted);">Only inside the function. <code>var</code> respects this, nothing else.</div>
          </div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">greet</span>() {
  <span class="kw">var</span> msg = <span class="str">"hello"</span>;    <span class="cm">// function-scoped</span>
  console.<span class="fn">log</span>(msg);    <span class="cm">// ‚úÖ</span>
}
console.<span class="fn">log</span>(msg);      <span class="cm">// ‚ùå ReferenceError</span>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:grid; grid-template-columns:200px 1fr; gap:16px; align-items:start;">
          <div>
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--accent3); font-weight:700; text-transform:uppercase; margin-bottom:6px;">‚ë¢ Block Scope</div>
            <div style="font-size:0.8rem; color:var(--muted);">Inside <code>{}</code>. Only <code>let</code> / <code>const</code> are block-scoped.</div>
          </div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
{
  <span class="kw">let</span> x = <span class="num">10</span>;    <span class="cm">// block-scoped ‚úÖ</span>
  <span class="kw">var</span> y = <span class="num">20</span>;    <span class="cm">// NOT block-scoped ‚Äî leaks out!</span>
}
console.<span class="fn">log</span>(y);  <span class="cm">// 20 ‚Äî var leaked</span>
console.<span class="fn">log</span>(x);  <span class="cm">// ReferenceError ‚Äî let did not leak</span>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:grid; grid-template-columns:200px 1fr; gap:16px; align-items:start;">
          <div>
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; text-transform:uppercase; margin-bottom:6px;">‚ë£ Module Scope</div>
            <div style="font-size:0.8rem; color:var(--muted);">ES Modules (<code>import</code>/<code>export</code>). Variables are file-private by default.</div>
          </div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="cm">// math.js</span>
<span class="kw">const</span> PI = <span class="num">3.14159</span>;         <span class="cm">// module-scoped: private</span>
<span class="kw">export const</span> TWO_PI = PI * <span class="num">2</span>;  <span class="cm">// exported: public</span>

<span class="cm">// other.js</span>
<span class="cm">// console.log(PI) ‚Üí Error: PI is not exported</span>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:grid; grid-template-columns:200px 1fr; gap:16px; align-items:start;">
          <div>
            <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--red); font-weight:700; text-transform:uppercase; margin-bottom:6px;">‚ë§ Lexical (Closure) Scope</div>
            <div style="font-size:0.8rem; color:var(--muted);">Inner functions can access outer vars. Set at write time, not call time.</div>
          </div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">outer</span>() {
  <span class="kw">const</span> secret = <span class="str">"inner can see me"</span>;
  <span class="kw">function</span> <span class="fn">inner</span>() {
    console.<span class="fn">log</span>(secret);  <span class="cm">// ‚úÖ via scope chain</span>
  }
  <span class="fn">inner</span>();
}
          </div>
        </div>
      </div>
    </div>

    <!-- When to use each -->
    <div style="margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:12px;">var vs let vs const ‚Äî Decision Rules</div>
      <table class="table">
        <thead>
          <tr><th>Keyword</th><th>Scope</th><th>Hoisted</th><th>Reassignable</th><th>When to use</th></tr>
        </thead>
        <tbody>
          <tr>
            <td><code style="color:var(--accent3);">var</code></td>
            <td>Function</td>
            <td class="yes">‚úÖ as undefined</td>
            <td class="yes">‚úÖ yes</td>
            <td style="color:var(--red);">Almost never. Use only when you intentionally need function scope that crosses blocks.</td>
          </tr>
          <tr>
            <td><code style="color:var(--fec);">let</code></td>
            <td>Block</td>
            <td class="partial">‚ö†Ô∏è TDZ</td>
            <td class="yes">‚úÖ yes</td>
            <td style="color:var(--green);">For variables that change over time: counters, loop vars, accumulating values.</td>
          </tr>
          <tr>
            <td><code style="color:var(--green);">const</code></td>
            <td>Block</td>
            <td class="partial">‚ö†Ô∏è TDZ</td>
            <td class="no">‚ùå no rebind</td>
            <td style="color:var(--green);">Default choice. Objects/arrays declared with const can still be mutated ‚Äî const only prevents reassignment of the binding.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="info-box amber">
      <strong>Golden rule:</strong> Prefer <code>const</code> by default. Use <code>let</code> only when you know the variable will be reassigned. Avoid <code>var</code> in modern code ‚Äî its function-scoping and hoisting behavior causes subtle bugs.
    </div>
  </div>

  <!-- SECTION 22: Closures ‚Äî When to Use and When NOT to -->
  <div class="card">
    <div class="section-title"><span>22</span> Closures ‚Äî When to Use, When to Avoid</div>

    <!-- When TO use -->
    <div style="margin-bottom:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--green); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">‚úÖ Good Uses of Closures</div>

      <div style="display:flex; flex-direction:column; gap:12px;">

        <div style="background:rgba(16,185,129,0.06); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:10px;">1. Data Privacy / Encapsulation</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="cm">// ‚ùå Without closure ‚Äî data exposed</span>
<span class="kw">let</span> count = <span class="num">0</span>;
<span class="kw">function</span> <span class="fn">increment</span>() { count++; }
<span class="cm">// Anyone can do: count = 9999</span>
            </div>
            <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="cm">// ‚úÖ With closure ‚Äî truly private</span>
<span class="kw">function</span> <span class="fn">createCounter</span>() {
  <span class="kw">let</span> count = <span class="num">0</span>;
  <span class="kw">return</span> { inc: () => ++count,
           get: () => count };
}
<span class="cm">// count is inaccessible from outside</span>
            </div>
          </div>
        </div>

        <div style="background:rgba(16,185,129,0.06); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:10px;">2. Memoization (Cache Expensive Results)</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">memoize</span>(fn) {
  <span class="kw">const</span> cache = {};          <span class="cm">// lives in closure ‚Äî persists between calls</span>
  <span class="kw">return function</span>(...args) {
    <span class="kw">const</span> key = JSON.<span class="fn">stringify</span>(args);
    <span class="kw">if</span> (key <span class="kw">in</span> cache) <span class="kw">return</span> cache[key];  <span class="cm">// cache hit</span>
    cache[key] = <span class="fn">fn</span>(...args);
    <span class="kw">return</span> cache[key];
  };
}
<span class="kw">const</span> expensiveAdd = <span class="fn">memoize</span>((a, b) => { <span class="cm">/* ... */</span> <span class="kw">return</span> a + b; });
<span class="fn">expensiveAdd</span>(<span class="num">2</span>, <span class="num">3</span>); <span class="cm">// computed: 5</span>
<span class="fn">expensiveAdd</span>(<span class="num">2</span>, <span class="num">3</span>); <span class="cm">// cache hit: 5 (no recompute)</span>
          </div>
          <div style="font-size:0.83rem; color:var(--muted); margin-top:10px;">The <code>cache</code> object lives in the closure ‚Äî it persists between calls, growing to remember more results. When <code>memoize</code> returns, its EC is gone from the stack but <code>cache</code> stays in the heap, accessible via the inner function's scope chain.</div>
        </div>

        <div style="background:rgba(16,185,129,0.06); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:10px;">3. Partial Application / Currying</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">multiply</span>(a) {
  <span class="kw">return</span> (b) => a * b;   <span class="cm">// closes over a</span>
}

<span class="kw">const</span> double = <span class="fn">multiply</span>(<span class="num">2</span>);
<span class="kw">const</span> triple = <span class="fn">multiply</span>(<span class="num">3</span>);

[<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>].<span class="fn">map</span>(double);  <span class="cm">// [2, 4, 6]</span>
[<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>].<span class="fn">map</span>(triple);  <span class="cm">// [3, 6, 9]</span>
          </div>
        </div>

        <div style="background:rgba(16,185,129,0.06); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:10px;">4. Event Handlers with Captured State</div>
          <div class="code-block" style="margin:0; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">setupButton</span>(buttonId, message) {
  <span class="kw">const</span> btn = document.<span class="fn">getElementById</span>(buttonId);
  btn.<span class="fn">addEventListener</span>(<span class="str">"click"</span>, () => {
    <span class="fn">alert</span>(message);   <span class="cm">// closes over message from outer scope</span>
  });
}

<span class="fn">setupButton</span>(<span class="str">"btn1"</span>, <span class="str">"Hello from button 1"</span>);
<span class="fn">setupButton</span>(<span class="str">"btn2"</span>, <span class="str">"Hello from button 2"</span>);
<span class="cm">// Each button remembers its own message ‚Äî no global needed</span>
          </div>
        </div>

      </div>
    </div>

    <!-- When NOT to use -->
    <div>
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--red); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:14px;">‚ùå When Closures Cause Problems</div>

      <div style="display:flex; flex-direction:column; gap:12px;">

        <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--red); font-weight:700; margin-bottom:10px;">1. Memory Leaks ‚Äî Holding onto Big Objects</div>
          <div class="code-block" style="margin:0 0 10px; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">processData</span>() {
  <span class="kw">const</span> hugeArray = <span class="kw">new</span> <span class="fn">Array</span>(<span class="num">1_000_000</span>).<span class="fn">fill</span>(<span class="str">"data"</span>);

  <span class="kw">return function</span> <span class="fn">getLength</span>() {
    <span class="kw">return</span> hugeArray.length;   <span class="cm">// only uses .length...</span>
  };
  <span class="cm">// ...but the ENTIRE hugeArray stays in memory</span>
  <span class="cm">// because the closure references it!</span>
}
<span class="kw">const</span> fn = <span class="fn">processData</span>();  <span class="cm">// 1M element array stuck in memory</span>
          </div>
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:10px; font-size:0.83rem;">
            <strong style="color:var(--green);">Fix:</strong> Extract only what's needed before closing: <code>const len = hugeArray.length;</code> then return a function that uses <code>len</code>, not <code>hugeArray</code>. The array can then be garbage collected.
          </div>
        </div>

        <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--red); font-weight:700; margin-bottom:10px;">2. Accidental Mutation ‚Äî Shared Mutable State</div>
          <div class="code-block" style="margin:0 0 10px; font-size:0.8rem;">
<span class="kw">function</span> <span class="fn">makeMultipliers</span>() {
  <span class="kw">const</span> fns = [];
  <span class="kw">for</span> (<span class="kw">var</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
    fns.<span class="fn">push</span>(() => i * i);   <span class="cm">// all close over the SAME i!</span>
  }
  <span class="kw">return</span> fns;
}
<span class="kw">const</span> multipliers = <span class="fn">makeMultipliers</span>();
multipliers[<span class="num">0</span>](); <span class="cm">// 9 (not 0!) ‚Äî i is 3 by the time we call</span>
multipliers[<span class="num">1</span>](); <span class="cm">// 9</span>
multipliers[<span class="num">2</span>](); <span class="cm">// 9</span>
          </div>
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.3); border-radius:8px; padding:10px; font-size:0.83rem;">
            <strong style="color:var(--green);">Fix:</strong> Use <code>let</code> in the loop ‚Äî it creates a new binding per iteration, so each closure captures its own <code>i</code>.
          </div>
        </div>

        <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.3); border-radius:12px; padding:18px;">
          <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--red); font-weight:700; margin-bottom:10px;">3. Over-engineering ‚Äî When a Class is Clearer</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div class="code-block" style="margin:0; font-size:0.78rem;">
<span class="cm">// Closure ‚Äî 10+ methods gets messy</span>
<span class="kw">function</span> <span class="fn">createUser</span>(name) {
  <span class="kw">let</span> score = <span class="num">0</span>;
  <span class="kw">return</span> {
    <span class="fn">getName</span>: () => name,
    <span class="fn">getScore</span>: () => score,
    <span class="fn">addScore</span>: (n) => score += n,
    <span class="fn">resetScore</span>: () => score = <span class="num">0</span>,
    <span class="cm">// ... 10 more methods</span>
  };
}
            </div>
            <div class="code-block" style="margin:0; font-size:0.78rem;">
<span class="cm">// Class ‚Äî clearer, prototype-efficient</span>
<span class="kw">class</span> User {
  <span class="fn">constructor</span>(name) {
    <span class="kw">this</span>.name = name;
    <span class="kw">this</span>.score = <span class="num">0</span>;
  }
  <span class="fn">addScore</span>(n) { <span class="kw">this</span>.score += n; }
  <span class="fn">resetScore</span>() { <span class="kw">this</span>.score = <span class="num">0</span>; }
  <span class="cm">// methods shared via prototype</span>
}
            </div>
          </div>
          <div style="font-size:0.83rem; color:var(--muted); margin-top:10px;">Closures create a new copy of every method per instance. Classes share methods on the prototype ‚Äî one copy in memory regardless of how many instances you create.</div>
        </div>

      </div>
    </div>

    <!-- Pros and Cons table -->
    <table class="table" style="margin-top:20px;">
      <thead>
        <tr><th>Aspect</th><th style="color:var(--green);">‚úÖ Pros</th><th style="color:var(--red);">‚ùå Cons</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Privacy</strong></td>
          <td>True encapsulation without classes</td>
          <td>No way to inspect private state from outside (debug harder)</td>
        </tr>
        <tr>
          <td><strong>Memory</strong></td>
          <td>Only keeps what's referenced alive</td>
          <td>Can cause leaks if large objects are captured unnecessarily</td>
        </tr>
        <tr>
          <td><strong>Flexibility</strong></td>
          <td>Function factories, currying, partial application</td>
          <td>Shared mutable state through closures can cause tricky bugs</td>
        </tr>
        <tr>
          <td><strong>Performance</strong></td>
          <td>Memoization can dramatically speed up expensive operations</td>
          <td>Each closure instance creates a new function object ‚Äî more memory than prototype methods</td>
        </tr>
        <tr>
          <td><strong>Readability</strong></td>
          <td>Elegant for small, focused utilities</td>
          <td>Deeply nested closures become hard to trace and debug</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- SECTION 23: Scope Pros, Cons, and Decision Guide -->
  <div class="card">
    <div class="section-title"><span>23</span> Scope ‚Äî Pros, Cons & Decision Guide</div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-bottom:20px;">
      <div>
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:10px;">‚úÖ Benefits of Proper Scoping</div>
        <div style="display:flex; flex-direction:column; gap:8px;">
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Collision prevention</strong> ‚Äî Variables in tight scopes don't accidentally overwrite each other in large codebases.</div>
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Garbage collection</strong> ‚Äî Variables go out of scope and get cleaned up, preventing memory leaks.</div>
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Readability</strong> ‚Äî Tight scope makes it clear what data a piece of code relies on.</div>
          <div style="background:rgba(16,185,129,0.08); border:1px solid rgba(16,185,129,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Security</strong> ‚Äî Sensitive data (tokens, passwords) can be kept out of global scope.</div>
        </div>
      </div>
      <div>
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--red); font-weight:700; text-transform:uppercase; letter-spacing:0.1em; margin-bottom:10px;">‚ùå Pitfalls of Poor Scoping</div>
        <div style="display:flex; flex-direction:column; gap:8px;">
          <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Global pollution</strong> ‚Äî Too many globals make code fragile and hard to test.</div>
          <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Temporal Dead Zone surprises</strong> ‚Äî Accessing <code>let</code>/<code>const</code> before declaration throws, even though the variable "exists".</div>
          <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">var leaking out of blocks</strong> ‚Äî <code>var</code> inside <code>if</code> or <code>for</code> leaks to the enclosing function, causing confusing behavior.</div>
          <div style="background:rgba(239,68,68,0.06); border:1px solid rgba(239,68,68,0.25); border-radius:8px; padding:12px; font-size:0.85rem; color:var(--muted); line-height:1.5;"><strong style="color:var(--text);">Shadowing bugs</strong> ‚Äî Declaring a variable with the same name in inner scope silently hides the outer one.</div>
        </div>
      </div>
    </div>

    <!-- The shadowing example -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px; margin-bottom:16px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--accent3); font-weight:700; text-transform:uppercase; margin-bottom:10px;">Shadowing ‚Äî The Silent Bug</div>
      <div class="code-block" style="margin:0 0 10px; font-size:0.82rem;">
<span class="kw">let</span> result = <span class="str">"initial"</span>;

<span class="kw">function</span> <span class="fn">process</span>() {
  <span class="kw">let</span> result = <span class="str">"processed"</span>;   <span class="cm">// shadows outer result ‚Äî no error!</span>
  console.<span class="fn">log</span>(result);          <span class="cm">// "processed" ‚Äî reads inner</span>
}

<span class="fn">process</span>();
console.<span class="fn">log</span>(result);            <span class="cm">// "initial" ‚Äî outer untouched</span>
<span class="cm">// Was this intentional? Probably not. Rename the inner variable!</span>
      </div>
      <div style="font-size:0.84rem; color:var(--muted);">Shadowing is legal JS but almost always a mistake. ESLint's <code>no-shadow</code> rule catches this. Use distinct variable names.</div>
    </div>

    <!-- Decision flowchart -->
    <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:20px;">
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em; margin-bottom:16px;">Scope Decision Guide</div>
      <div style="display:flex; flex-direction:column; gap:10px; font-size:0.88rem;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="width:8px; height:8px; border-radius:50%; background:var(--gec); flex-shrink:0; margin-top:6px;"></div>
          <div><strong style="color:var(--text);">Used in the entire app?</strong> <span style="color:var(--muted);">‚Üí Global or module export. But keep globals to absolute minimum.</span></div>
        </div>
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="width:8px; height:8px; border-radius:50%; background:var(--fec); flex-shrink:0; margin-top:6px;"></div>
          <div><strong style="color:var(--text);">Used only inside a function?</strong> <span style="color:var(--muted);">‚Üí Declare it inside that function, as <code>const</code> or <code>let</code>.</span></div>
        </div>
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="width:8px; height:8px; border-radius:50%; background:var(--accent3); flex-shrink:0; margin-top:6px;"></div>
          <div><strong style="color:var(--text);">Used only inside an if/loop block?</strong> <span style="color:var(--muted);">‚Üí Declare it inside that block with <code>const</code>/<code>let</code>.</span></div>
        </div>
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="width:8px; height:8px; border-radius:50%; background:var(--green); flex-shrink:0; margin-top:6px;"></div>
          <div><strong style="color:var(--text);">Does it change after assignment?</strong> <span style="color:var(--muted);">‚Üí If yes, <code>let</code>. If no, <code>const</code>.</span></div>
        </div>
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="width:8px; height:8px; border-radius:50%; background:var(--red); flex-shrink:0; margin-top:6px;"></div>
          <div><strong style="color:var(--text);">Do multiple functions need to share state?</strong> <span style="color:var(--muted);">‚Üí Consider a closure, class, or module-level variable ‚Äî not a global.</span></div>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 24: Code Explained ‚Äî BankAccount Module Pattern -->
  <div class="card">
    <div class="section-title"><span>24</span> Line-by-Line: Bank Account Module Pattern</div>
    <p>The bank account example combines closures, scopes, and the module pattern. Let's trace exactly what happens in memory and why this design choice is superior to using a plain object.</p>

    <div class="code-block" style="margin-bottom:20px;">
<span style="color:#475569; margin-right:14px; user-select:none;">L1 </span><span class="kw">function</span> <span class="fn">createBankAccount</span>(initialBalance) {
<span style="color:#475569; margin-right:14px; user-select:none;">L2 </span>  <span class="kw">let</span> balance = initialBalance;
<span style="color:#475569; margin-right:14px; user-select:none;">L3 </span>
<span style="color:#475569; margin-right:14px; user-select:none;">L4 </span>  <span class="kw">return</span> {
<span style="color:#475569; margin-right:14px; user-select:none;">L5 </span>    <span class="fn">deposit</span>(amount)  { balance += amount; },
<span style="color:#475569; margin-right:14px; user-select:none;">L6 </span>    <span class="fn">withdraw</span>(amount) {
<span style="color:#475569; margin-right:14px; user-select:none;">L7 </span>      <span class="kw">if</span> (amount > balance) <span class="kw">throw</span> <span class="kw">new</span> <span class="fn">Error</span>(<span class="str">"Insufficient funds"</span>);
<span style="color:#475569; margin-right:14px; user-select:none;">L8 </span>      balance -= amount;
<span style="color:#475569; margin-right:14px; user-select:none;">L9 </span>    },
<span style="color:#475569; margin-right:14px; user-select:none;">L10</span>    <span class="fn">getBalance</span>() { <span class="kw">return</span> balance; }
<span style="color:#475569; margin-right:14px; user-select:none;">L11</span>  };
<span style="color:#475569; margin-right:14px; user-select:none;">L12</span>}
<span style="color:#475569; margin-right:14px; user-select:none;">L13</span>
<span style="color:#475569; margin-right:14px; user-select:none;">L14</span><span class="kw">const</span> acc = <span class="fn">createBankAccount</span>(<span class="num">100</span>);
<span style="color:#475569; margin-right:14px; user-select:none;">L15</span>acc.<span class="fn">deposit</span>(<span class="num">50</span>);
<span style="color:#475569; margin-right:14px; user-select:none;">L16</span>console.<span class="fn">log</span>(acc.<span class="fn">getBalance</span>());  <span class="cm">// 150</span>
<span style="color:#475569; margin-right:14px; user-select:none;">L17</span>console.<span class="fn">log</span>(acc.balance);         <span class="cm">// undefined ‚Äî truly private!</span>
    </div>

    <div style="display:flex; flex-direction:column; gap:12px;">

      <div style="background:var(--surface2); border-left:3px solid var(--gec); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--gec); font-weight:700; margin-bottom:8px;">L2 ‚Äî let balance = initialBalance</div>
        <p style="margin:0; font-size:0.88rem;">This is the <strong>private state</strong>. It lives in <code>createBankAccount</code>'s Lexical Environment. Critically, <code>balance</code> is declared with <code>let</code>, which means it can be mutated ‚Äî but only by code that has access to this Lexical Environment (the returned methods). No outside code can touch it.</p>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--fec); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--fec); font-weight:700; margin-bottom:8px;">L4‚ÄìL11 ‚Äî return { deposit, withdraw, getBalance }</div>
        <p style="margin:0 0 8px; font-size:0.88rem;">Three method functions are created. Each one is a closure over the same Lexical Environment containing <code>balance</code>. They are <strong>all looking at the same <code>balance</code></strong> ‚Äî so when <code>deposit</code> increases it, <code>getBalance</code> returns the updated value.</p>
        <div style="background:rgba(6,182,212,0.1); border:1px solid rgba(6,182,212,0.3); border-radius:8px; padding:10px; font-family:'JetBrains Mono',monospace; font-size:0.8rem; color:#a5f3fc;">
          deposit.[[Environment]] ‚Üí { balance: 100, initialBalance: 100 }<br>
          withdraw.[[Environment]] ‚Üí same env above ‚Üë<br>
          getBalance.[[Environment]] ‚Üí same env above ‚Üë
        </div>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--accent3); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--accent3); font-weight:700; margin-bottom:8px;">L15 ‚Äî acc.deposit(50)</div>
        <p style="margin:0; font-size:0.88rem;">When deposit is called, a new Function EC is pushed. Inside it, <code>amount = 50</code>. The line <code>balance += amount</code> looks up <code>balance</code> ‚Äî not found in local env, found in the closure env ‚Üí <code>balance = 100</code>. Updates it to <code>150</code>. EC is popped. The closure env now holds <code>{ balance: 150 }</code>.</p>
      </div>

      <div style="background:var(--surface2); border-left:3px solid var(--green); border-radius:0 10px 10px 0; padding:16px;">
        <div style="font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--green); font-weight:700; margin-bottom:8px;">L17 ‚Äî acc.balance ‚Üí undefined</div>
        <p style="margin:0; font-size:0.88rem;"><code>acc</code> is a plain JS object <code>{ deposit: fn, withdraw: fn, getBalance: fn }</code>. It has no <code>balance</code> property on it ‚Äî <code>balance</code> only exists inside the closure's Lexical Environment, which is invisible to outside code. This is <strong>genuine data privacy</strong> ‚Äî not convention-based (like <code>_balance</code>), but structurally enforced by scope.</p>
      </div>

    </div>
  </div>

  <!-- SECTION 25: Common Misconceptions Cleared -->
  <div class="card">
    <div class="section-title"><span>25</span> 8 Common Misconceptions ‚Äî Cleared</div>

    <div style="display:flex; flex-direction:column; gap:12px;">

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 1</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"Closures are a special feature you have to explicitly create."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> Every function in JavaScript is a closure. Even a simple function at the top level closes over the global scope. Closures are not opt-in ‚Äî they're just how the language works via Lexical Environments.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 2</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"async/await makes JavaScript multi-threaded."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> JS is still single-threaded. <code>async/await</code> doesn't add threads ‚Äî it pauses (suspends) a function's EC and lets other synchronous code run. The actual I/O (fetch, file read) happens in the browser's C++ internals, outside the JS thread.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 3</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"setTimeout(fn, 0) runs immediately."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> It runs "as soon as possible" ‚Äî but only after the current synchronous code AND all microtasks have finished. <code>setTimeout(fn, 0)</code> schedules a macrotask, which has the lowest priority in the event loop.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 4</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"const means the value can never change."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> <code>const</code> prevents <em>rebinding</em> of the variable ‚Äî you can't make it point to a different object. But the object itself is fully mutable: <code>const arr = []; arr.push(1)</code> works fine.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 5</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"Arrow functions are just shorthand for regular functions."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> Arrow functions have fundamentally different behavior: no own <code>this</code>, no <code>arguments</code> object, can't be used as constructors (<code>new</code>), no <code>prototype</code> property. They're not interchangeable ‚Äî they solve different problems.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 6</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"let and const are hoisted differently from var ‚Äî they're not hoisted at all."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> All declarations are hoisted. The difference is that <code>let</code>/<code>const</code> are placed in the <strong>Temporal Dead Zone (TDZ)</strong> ‚Äî they exist but cannot be accessed until the declaration line is reached. This is why accessing them early throws a ReferenceError, not silently returning <code>undefined</code> like <code>var</code>.</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 7</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"Closures always cause memory leaks."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> Closures only retain what they actually reference. Modern JS engines (V8, SpiderMonkey) are smart enough to only keep variables that are actually used by the inner function. A closure only causes a leak if you hold a reference to the inner function longer than necessary (e.g., forgot to remove an event listener).</div>
          </div>
        </div>
      </div>

      <div style="background:var(--surface2); border:1px solid var(--border); border-radius:12px; padding:18px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="background:var(--red); color:white; font-weight:700; font-size:0.72rem; padding:4px 10px; border-radius:100px; flex-shrink:0; margin-top:2px; font-family:'JetBrains Mono',monospace;">MYTH 8</div>
          <div>
            <div style="font-size:0.88rem; color:var(--text); margin-bottom:6px;"><strong>"The Execution Context is the same as scope."</strong></div>
            <div style="font-size:0.84rem; color:var(--muted);">‚úÖ <strong>Reality:</strong> Scope is a <em>concept</em> ‚Äî the rules for which variables are accessible where. Execution Context is the <em>runtime implementation</em> ‚Äî the actual object created by the engine to execute code. The Lexical Environment inside the EC is what <em>implements</em> scope.</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- SECTION 26: Summary -->
  <div class="card">
    <div class="section-title"><span>26</span> Summary ‚Äî Complete Mental Model</div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 8px;">
      <div class="info-box purple">
        <strong>Execution Context</strong><br>An environment box for running code. Contains: Variable Env, Lexical Env, and <code>this</code>.
      </div>
      <div class="info-box cyan">
        <strong>2 Phases</strong><br>Creation (hoisting, memory allocation) then Execution (code runs line by line).
      </div>
      <div class="info-box amber">
        <strong>Call Stack</strong><br>LIFO stack tracking which EC is active. Global EC always at bottom, function ECs stacked on top.
      </div>
      <div class="info-box purple" style="border-color: var(--green);">
        <strong>Lexical Environment</strong><br>Environment Record (variables) + outer reference (scope chain). Each block creates its own. Foundation of closures.
      </div>
      <div class="info-box" style="background:rgba(16,185,129,0.1); border-left:3px solid var(--green);">
        <strong>Microtasks</strong> (Promise.then, await)<br><span style="color:var(--muted);">Run after every sync task, before any macrotask. Entire queue drained before moving on.</span>
      </div>
      <div class="info-box amber">
        <strong>Macrotasks</strong> (setTimeout, setInterval)<br><span style="color:var(--muted);">One per event loop tick. Always run after microtasks are fully drained.</span>
      </div>
      <div class="info-box cyan">
        <strong>Closures</strong><br><span style="color:var(--muted);">Functions remember their Lexical Env at definition time. Enables private state, function factories, memoization.</span>
      </div>
      <div class="info-box purple">
        <strong>this Binding</strong><br><span style="color:var(--muted);">Determined at call time: new &gt; call/apply/bind &gt; method call &gt; default. Arrow functions have no own <code>this</code>.</span>
      </div>
      <div class="info-box" style="background:rgba(16,185,129,0.1); border-left:3px solid var(--fec); grid-column: 1 / -1;">
        <strong>async/await + Event Loop</strong><br>
        <span style="color:var(--muted);">JS is single-threaded. <code>await</code> suspends the function's EC (saves state, pops off stack), freeing the thread. EC restored via microtask queue when Promise resolves. Use <code>Promise.all</code> for parallel, <code>Promise.allSettled</code> for fault-tolerant, <code>Promise.race</code> for timeouts, <code>Promise.any</code> for first-success patterns.</span>
      </div>
    </div>
  </div>

</div>

<script>
const steps = [
  {
    label: "STEP 1",
    desc: "Global EC is created and pushed onto the stack. JS starts executing the file.",
    hint: "var declarations are hoisted, function declarations stored",
    stack: [{ label: "Global EC", type: "gec", badge: "GEC" }]
  },
  {
    label: "STEP 2",
    desc: "square(4) is called on line 9. A new Function EC for square() is created and pushed.",
    hint: "square's EC gets its own Variable Env with n = 4",
    stack: [
      { label: "Global EC", type: "gec", badge: "GEC" },
      { label: "square(4)", type: "fec", badge: "FEC" }
    ]
  },
  {
    label: "STEP 3",
    desc: "Inside square(), multiply(n,n) is called. A new EC for multiply() is pushed on top.",
    hint: "multiply's EC has a = 4, b = 4",
    stack: [
      { label: "Global EC", type: "gec", badge: "GEC" },
      { label: "square(4)", type: "fec", badge: "FEC" },
      { label: "multiply(4, 4)", type: "fec2", badge: "FEC" }
    ]
  },
  {
    label: "STEP 4",
    desc: "multiply() finishes (returns 16). Its EC is popped off the stack. Control returns to square().",
    hint: "Memory for multiply's EC is freed",
    stack: [
      { label: "Global EC", type: "gec", badge: "GEC" },
      { label: "square(4)", type: "fec", badge: "FEC" }
    ]
  },
  {
    label: "STEP 5",
    desc: "square() finishes (returns 16). Its EC is popped. result = 16 is set in Global EC.",
    hint: "Back in Global EC, result is now 16",
    stack: [
      { label: "Global EC", type: "gec", badge: "GEC" }
    ]
  },
  {
    label: "STEP 6",
    desc: "console.log(result) runs and prints 16. When the script finishes, Global EC is also removed.",
    hint: "Program complete ‚Äî stack empty",
    stack: []
  }
];

let currentStep = -1;

function renderStack(items) {
  const stackEl = document.getElementById('stack');
  const emptyMsg = document.getElementById('empty-msg');
  const existingItems = stackEl.querySelectorAll('.stack-item');
  existingItems.forEach(e => e.remove());

  if (items.length === 0) {
    emptyMsg.style.display = 'block';
    emptyMsg.textContent = '‚úÖ Stack is empty ‚Äî program complete!';
    emptyMsg.style.color = 'var(--green)';
  } else {
    emptyMsg.style.display = 'none';
    items.forEach(item => {
      const el = document.createElement('div');
      el.className = `stack-item ${item.type}`;
      el.innerHTML = `<span>${item.label}</span><span class="stack-badge">${item.badge}</span>`;
      stackEl.appendChild(el);
    });
  }
}

function renderSteps() {
  const container = document.getElementById('steps-info');
  container.innerHTML = steps.map((s, i) => `
    <div class="step-item ${i === currentStep ? 'active' : ''}" onclick="goToStep(${i})">
      <div class="step-num">${s.label}</div>
      <div class="step-desc">${s.desc}</div>
      ${i === currentStep ? `<div class="step-hint">üí° ${s.hint}</div>` : ''}
    </div>
  `).join('');
}

function nextStep() {
  if (currentStep < steps.length - 1) {
    currentStep++;
    renderStack(steps[currentStep].stack);
    renderSteps();
  }
}

function goToStep(i) {
  currentStep = i;
  renderStack(steps[currentStep].stack);
  renderSteps();
}

function resetDemo() {
  currentStep = -1;
  const stackEl = document.getElementById('stack');
  stackEl.querySelectorAll('.stack-item').forEach(e => e.remove());
  const emptyMsg = document.getElementById('empty-msg');
  emptyMsg.style.display = 'block';
  emptyMsg.textContent = 'Stack is empty ‚Äî press Next Step';
  emptyMsg.style.color = 'var(--muted)';
  renderSteps();
}

renderSteps();

// ‚îÄ‚îÄ‚îÄ Event Loop Simulator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const elStates = [
  {
    tick: 0,
    stack: [],
    micro: [],
    macro: [],
    console: [],
    explain: "Press \"Next Tick\" to start. We have a script to execute."
  },
  {
    tick: 1,
    stack: ["Global EC", "console.log(\"script start\")"],
    micro: [],
    macro: [],
    console: ["script start"],
    explain: "Sync: console.log(\"script start\") runs immediately on the call stack."
  },
  {
    tick: 2,
    stack: ["Global EC", "setTimeout(cb1, 0)"],
    micro: [],
    macro: ["cb1"],
    console: ["script start"],
    explain: "setTimeout(cb1, 0) is called. The browser's timer API handles it. When the timer fires (immediately at 0ms), cb1 is placed in the Macrotask Queue ‚Äî NOT directly on the stack."
  },
  {
    tick: 3,
    stack: ["Global EC", "Promise.resolve().then(cb2)"],
    micro: ["cb2"],
    macro: ["cb1"],
    console: ["script start"],
    explain: "Promise.resolve() is already resolved, so cb2 is immediately queued into the Microtask Queue. Note: it doesn't run yet ‚Äî sync code is still running."
  },
  {
    tick: 4,
    stack: ["Global EC", "Promise.resolve().then(cb3)"],
    micro: ["cb2", "cb3"],
    macro: ["cb1"],
    console: ["script start"],
    explain: "Same for cb3 ‚Äî it's queued into the Microtask Queue behind cb2. Still waiting for sync code to finish."
  },
  {
    tick: 5,
    stack: ["Global EC", "console.log(\"script end\")"],
    micro: ["cb2", "cb3"],
    macro: ["cb1"],
    console: ["script start", "script end"],
    explain: "Sync: console.log(\"script end\") runs. This is the last synchronous line in the script."
  },
  {
    tick: 6,
    stack: ["Global EC"],
    micro: ["cb2", "cb3"],
    macro: ["cb1"],
    console: ["script start", "script end"],
    explain: "Sync code is done! The call stack is now only the Global EC. Event Loop checks: are there microtasks? YES ‚Äî cb2 and cb3 are waiting. Microtasks run BEFORE any macrotask."
  },
  {
    tick: 7,
    stack: ["Global EC", "cb2 (microtask)"],
    micro: ["cb3"],
    macro: ["cb1"],
    console: ["script start", "script end", "‚úì cb2 ran"],
    explain: "cb2 is pulled from the Microtask Queue and pushed onto the call stack. It runs (imagine it logs something). Microtask queue still has cb3."
  },
  {
    tick: 8,
    stack: ["Global EC", "cb3 (microtask)"],
    micro: [],
    macro: ["cb1"],
    console: ["script start", "script end", "‚úì cb2 ran", "‚úì cb3 ran"],
    explain: "cb2 finished and was popped. Now cb3 is pulled from Microtask Queue. ALL microtasks must drain before any macrotask runs."
  },
  {
    tick: 9,
    stack: ["Global EC"],
    micro: [],
    macro: ["cb1"],
    console: ["script start", "script end", "‚úì cb2 ran", "‚úì cb3 ran"],
    explain: "Microtask queue is now empty! Event Loop checks macrotask queue. cb1 (our setTimeout callback) is waiting. It will be picked up next."
  },
  {
    tick: 10,
    stack: ["Global EC", "cb1 (macrotask)"],
    micro: [],
    macro: [],
    console: ["script start", "script end", "‚úì cb2 ran", "‚úì cb3 ran", "‚úì cb1 ran"],
    explain: "One macrotask is pulled: cb1 runs on the call stack. After it finishes, the Event Loop will check microtasks again (there are none), then check macrotasks (also empty). Done!"
  },
  {
    tick: 11,
    stack: ["Global EC"],
    micro: [],
    macro: [],
    console: ["script start", "script end", "‚úì cb2 ran", "‚úì cb3 ran", "‚úì cb1 ran"],
    explain: "‚úÖ All done! Final order: script start ‚Üí script end ‚Üí cb2 ‚Üí cb3 ‚Üí cb1. Sync first, then all microtasks, then one macrotask per loop tick."
  }
];

let elStep = 0;

function renderElState(state) {
  // Stack
  const stackEl = document.getElementById('el-stack');
  const stackEmpty = document.getElementById('el-stack-empty');
  stackEl.innerHTML = '';
  if (state.stack.length === 0) {
    stackEl.innerHTML = '<div style="text-align:center; color:var(--muted); font-size:0.75rem;" id="el-stack-empty">empty</div>';
  } else {
    state.stack.forEach((item, i) => {
      const el = document.createElement('div');
      const isTop = i === state.stack.length - 1;
      el.style.cssText = `padding:7px 12px; border-radius:7px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; animation:slideIn 0.3s ease; border:1px solid;`;
      if (item === 'Global EC') {
        el.style.background = 'rgba(124,58,237,0.2)';
        el.style.borderColor = 'rgba(124,58,237,0.5)';
        el.style.color = '#c4b5fd';
      } else {
        el.style.background = isTop ? 'rgba(6,182,212,0.25)' : 'rgba(6,182,212,0.1)';
        el.style.borderColor = isTop ? 'var(--fec)' : 'rgba(6,182,212,0.3)';
        el.style.color = isTop ? '#a5f3fc' : 'var(--muted)';
      }
      el.textContent = item;
      stackEl.appendChild(el);
    });
  }

  // Microtask
  const microEl = document.getElementById('el-micro');
  microEl.innerHTML = '';
  if (state.micro.length === 0) {
    microEl.innerHTML = '<div style="text-align:center; color:var(--muted); font-size:0.75rem;">empty</div>';
  } else {
    state.micro.forEach((item, i) => {
      const el = document.createElement('div');
      el.style.cssText = `padding:7px 12px; border-radius:7px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; background:rgba(16,185,129,0.15); border:1px solid rgba(16,185,129,0.4); color:#6ee7b7; animation:slideIn 0.3s ease;`;
      el.textContent = (i === 0 ? '‚Üí ' : '   ') + item;
      microEl.appendChild(el);
    });
  }

  // Macrotask
  const macroEl = document.getElementById('el-macro');
  macroEl.innerHTML = '';
  if (state.macro.length === 0) {
    macroEl.innerHTML = '<div style="text-align:center; color:var(--muted); font-size:0.75rem;">empty</div>';
  } else {
    state.macro.forEach((item, i) => {
      const el = document.createElement('div');
      el.style.cssText = `padding:7px 12px; border-radius:7px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; background:rgba(245,158,11,0.15); border:1px solid rgba(245,158,11,0.4); color:#fde68a; animation:slideIn 0.3s ease;`;
      el.textContent = (i === 0 ? '‚Üí ' : '   ') + item;
      macroEl.appendChild(el);
    });
  }

  // Console
  const consoleEl = document.getElementById('el-console');
  consoleEl.innerHTML = state.console.map(l => `<div style="animation:slideIn 0.2s ease;">&gt; ${l}</div>`).join('');

  // Explanation
  document.getElementById('el-explain').textContent = state.explain;

  // Tick
  document.getElementById('el-tick-num').textContent = state.tick;
}

function elNext() {
  if (elStep < elStates.length - 1) {
    elStep++;
    renderElState(elStates[elStep]);
  }
}

function elReset() {
  elStep = 0;
  renderElState(elStates[0]);
}

renderElState(elStates[0]);
</script>
</body>
</html>
